/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.0.sdk/usr/include/dispatch/once.h:
       |    1|/*
       |    2| * Copyright (c) 2008-2010 Apple Inc. All rights reserved.
       |    3| *
       |    4| * @APPLE_APACHE_LICENSE_HEADER_START@
       |    5| *
       |    6| * Licensed under the Apache License, Version 2.0 (the "License");
       |    7| * you may not use this file except in compliance with the License.
       |    8| * You may obtain a copy of the License at
       |    9| *
       |   10| *     http://www.apache.org/licenses/LICENSE-2.0
       |   11| *
       |   12| * Unless required by applicable law or agreed to in writing, software
       |   13| * distributed under the License is distributed on an "AS IS" BASIS,
       |   14| * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       |   15| * See the License for the specific language governing permissions and
       |   16| * limitations under the License.
       |   17| *
       |   18| * @APPLE_APACHE_LICENSE_HEADER_END@
       |   19| */
       |   20|
       |   21|#ifndef __DISPATCH_ONCE__
       |   22|#define __DISPATCH_ONCE__
       |   23|
       |   24|#ifndef __DISPATCH_INDIRECT__
       |   25|#error "Please #include <dispatch/dispatch.h> instead of this file directly."
       |   26|#include <dispatch/base.h> // for HeaderDoc
       |   27|#endif
       |   28|
       |   29|DISPATCH_ASSUME_NONNULL_BEGIN
       |   30|
       |   31|__BEGIN_DECLS
       |   32|
       |   33|/*!
       |   34| * @typedef dispatch_once_t
       |   35| *
       |   36| * @abstract
       |   37| * A predicate for use with dispatch_once(). It must be initialized to zero.
       |   38| * Note: static and global variables default to zero.
       |   39| */
       |   40|DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
       |   41|typedef long dispatch_once_t;
       |   42|
       |   43|/*!
       |   44| * @function dispatch_once
       |   45| *
       |   46| * @abstract
       |   47| * Execute a block once and only once.
       |   48| *
       |   49| * @param predicate
       |   50| * A pointer to a dispatch_once_t that is used to test whether the block has
       |   51| * completed or not.
       |   52| *
       |   53| * @param block
       |   54| * The block to execute once.
       |   55| *
       |   56| * @discussion
       |   57| * Always call dispatch_once() before using or testing any variables that are
       |   58| * initialized by the block.
       |   59| */
       |   60|#ifdef __BLOCKS__
       |   61|__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
       |   62|DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
       |   63|DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
       |   64|void
       |   65|dispatch_once(dispatch_once_t *predicate,
       |   66|		DISPATCH_NOESCAPE dispatch_block_t block);
       |   67|
       |   68|DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW
       |   69|DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
       |   70|void
       |   71|_dispatch_once(dispatch_once_t *predicate,
       |   72|		DISPATCH_NOESCAPE dispatch_block_t block)
       |   73|{
       |   74|	if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {
       |   75|		dispatch_once(predicate, block);
       |   76|	} else {
       |   77|		dispatch_compiler_barrier();
       |   78|	}
       |   79|	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);
       |   80|}
       |   81|#undef dispatch_once
      2|   82|#define dispatch_once _dispatch_once
       |   83|#endif
       |   84|
       |   85|__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)
       |   86|DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW
       |   87|DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
       |   88|void
       |   89|dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context,
       |   90|		dispatch_function_t function);
       |   91|
       |   92|DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL1 DISPATCH_NONNULL3
       |   93|DISPATCH_NOTHROW
       |   94|DISPATCH_SWIFT3_UNAVAILABLE("Use lazily initialized globals instead")
       |   95|void
       |   96|_dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context,
       |   97|		dispatch_function_t function)
       |   98|{
       |   99|	if (DISPATCH_EXPECT(*predicate, ~0l) != ~0l) {
       |  100|		dispatch_once_f(predicate, context, function);
       |  101|	} else {
       |  102|		dispatch_compiler_barrier();
       |  103|	}
       |  104|	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);
       |  105|}
       |  106|#undef dispatch_once_f
       |  107|#define dispatch_once_f _dispatch_once_f
       |  108|
       |  109|__END_DECLS
       |  110|
       |  111|DISPATCH_ASSUME_NONNULL_END
       |  112|
       |  113|#endif

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.0.sdk/usr/include/objc/objc.h:
       |    1|/*
       |    2| * Copyright (c) 1999-2007 Apple Inc.  All Rights Reserved.
       |    3| * 
       |    4| * @APPLE_LICENSE_HEADER_START@
       |    5| * 
       |    6| * This file contains Original Code and/or Modifications of Original Code
       |    7| * as defined in and that are subject to the Apple Public Source License
       |    8| * Version 2.0 (the 'License'). You may not use this file except in
       |    9| * compliance with the License. Please obtain a copy of the License at
       |   10| * http://www.opensource.apple.com/apsl/ and read it before using this
       |   11| * file.
       |   12| * 
       |   13| * The Original Code and all software distributed under the License are
       |   14| * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
       |   15| * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
       |   16| * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
       |   18| * Please see the License for the specific language governing rights and
       |   19| * limitations under the License.
       |   20| * 
       |   21| * @APPLE_LICENSE_HEADER_END@
       |   22| */
       |   23|/*
       |   24| *	objc.h
       |   25| *	Copyright 1988-1996, NeXT Software, Inc.
       |   26| */
       |   27|
       |   28|#ifndef _OBJC_OBJC_H_
       |   29|#define _OBJC_OBJC_H_
       |   30|
       |   31|#include <sys/types.h>      // for __DARWIN_NULL
       |   32|#include <Availability.h>
       |   33|#include <objc/objc-api.h>
       |   34|#include <stdbool.h>
       |   35|
       |   36|#if !OBJC_TYPES_DEFINED
       |   37|/// An opaque type that represents an Objective-C class.
       |   38|typedef struct objc_class *Class;
       |   39|
       |   40|/// Represents an instance of a class.
       |   41|struct objc_object {
       |   42|    Class isa  OBJC_ISA_AVAILABILITY;
       |   43|};
       |   44|
       |   45|/// A pointer to an instance of a class.
       |   46|typedef struct objc_object *id;
       |   47|#endif
       |   48|
       |   49|/// An opaque type that represents a method selector.
       |   50|typedef struct objc_selector *SEL;
       |   51|
       |   52|/// A pointer to the function of a method implementation. 
       |   53|#if !OBJC_OLD_DISPATCH_PROTOTYPES
       |   54|typedef void (*IMP)(void /* id, SEL, ... */ ); 
       |   55|#else
       |   56|typedef id (*IMP)(id, SEL, ...); 
       |   57|#endif
       |   58|
       |   59|#define OBJC_BOOL_DEFINED
       |   60|
       |   61|/// Type to represent a boolean value.
       |   62|#if (TARGET_OS_IPHONE && __LP64__)  ||  TARGET_OS_WATCH
       |   63|#define OBJC_BOOL_IS_BOOL 1
       |   64|typedef bool BOOL;
       |   65|#else
       |   66|#define OBJC_BOOL_IS_CHAR 1
       |   67|typedef signed char BOOL; 
       |   68|// BOOL is explicitly signed so @encode(BOOL) == "c" rather than "C" 
       |   69|// even if -funsigned-char is used.
       |   70|#endif
       |   71|
       |   72|#if __has_feature(objc_bool)
       |   73|#define YES __objc_yes
      0|   74|#define NO  __objc_no
       |   75|#else
       |   76|#define YES ((BOOL)1)
       |   77|#define NO  ((BOOL)0)
       |   78|#endif
       |   79|
       |   80|#ifndef Nil
       |   81|# if __has_feature(cxx_nullptr)
       |   82|#   define Nil nullptr
       |   83|# else
       |   84|#   define Nil __DARWIN_NULL
       |   85|# endif
       |   86|#endif
       |   87|
       |   88|#ifndef nil
       |   89|# if __has_feature(cxx_nullptr)
       |   90|#   define nil nullptr
       |   91|# else
      0|   92|#   define nil __DARWIN_NULL
       |   93|# endif
       |   94|#endif
       |   95|
       |   96|#ifndef __strong
       |   97|# if !__has_feature(objc_arc)
       |   98|#   define __strong /* empty */
       |   99|# endif
       |  100|#endif
       |  101|
       |  102|#ifndef __unsafe_unretained
       |  103|# if !__has_feature(objc_arc)
       |  104|#   define __unsafe_unretained /* empty */
       |  105|# endif
       |  106|#endif
       |  107|
       |  108|#ifndef __autoreleasing
       |  109|# if !__has_feature(objc_arc)
       |  110|#   define __autoreleasing /* empty */
       |  111|# endif
       |  112|#endif
       |  113|
       |  114|
       |  115|/** 
       |  116| * Returns the name of the method specified by a given selector.
       |  117| * 
       |  118| * @param sel A pointer of type \c SEL. Pass the selector whose name you wish to determine.
       |  119| * 
       |  120| * @return A C string indicating the name of the selector.
       |  121| */
       |  122|OBJC_EXPORT const char *sel_getName(SEL sel)
       |  123|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  124|
       |  125|/** 
       |  126| * Registers a method with the Objective-C runtime system, maps the method 
       |  127| * name to a selector, and returns the selector value.
       |  128| * 
       |  129| * @param str A pointer to a C string. Pass the name of the method you wish to register.
       |  130| * 
       |  131| * @return A pointer of type SEL specifying the selector for the named method.
       |  132| * 
       |  133| * @note You must register a method name with the Objective-C runtime system to obtain the
       |  134| *  methodâ€™s selector before you can add the method to a class definition. If the method name
       |  135| *  has already been registered, this function simply returns the selector.
       |  136| */
       |  137|OBJC_EXPORT SEL sel_registerName(const char *str)
       |  138|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  139|
       |  140|/** 
       |  141| * Returns the class name of a given object.
       |  142| * 
       |  143| * @param obj An Objective-C object.
       |  144| * 
       |  145| * @return The name of the class of which \e obj is an instance.
       |  146| */
       |  147|OBJC_EXPORT const char *object_getClassName(id obj)
       |  148|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  149|
       |  150|/** 
       |  151| * Returns a pointer to any extra bytes allocated with an instance given object.
       |  152| * 
       |  153| * @param obj An Objective-C object.
       |  154| * 
       |  155| * @return A pointer to any extra bytes allocated with \e obj. If \e obj was
       |  156| *   not allocated with any extra bytes, then dereferencing the returned pointer is undefined.
       |  157| * 
       |  158| * @note This function returns a pointer to any extra bytes allocated with the instance
       |  159| *  (as specified by \c class_createInstance with extraBytes>0). This memory follows the
       |  160| *  object's ordinary ivars, but may not be adjacent to the last ivar.
       |  161| * @note The returned pointer is guaranteed to be pointer-size aligned, even if the area following
       |  162| *  the object's last ivar is less aligned than that. Alignment greater than pointer-size is never
       |  163| *  guaranteed, even if the area following the object's last ivar is more aligned than that.
       |  164| * @note In a garbage-collected environment, the memory is scanned conservatively.
       |  165| */
       |  166|OBJC_EXPORT void *object_getIndexedIvars(id obj)
       |  167|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  168|
       |  169|/** 
       |  170| * Identifies a selector as being valid or invalid.
       |  171| * 
       |  172| * @param sel The selector you want to identify.
       |  173| * 
       |  174| * @return YES if selector is valid and has a function implementation, NO otherwise. 
       |  175| * 
       |  176| * @warning On some platforms, an invalid reference (to invalid memory addresses) can cause
       |  177| *  a crash. 
       |  178| */
       |  179|OBJC_EXPORT BOOL sel_isMapped(SEL sel)
       |  180|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  181|
       |  182|/** 
       |  183| * Registers a method name with the Objective-C runtime system.
       |  184| * 
       |  185| * @param str A pointer to a C string. Pass the name of the method you wish to register.
       |  186| * 
       |  187| * @return A pointer of type SEL specifying the selector for the named method.
       |  188| * 
       |  189| * @note The implementation of this method is identical to the implementation of \c sel_registerName.
       |  190| * @note Prior to OS X version 10.0, this method tried to find the selector mapped to the given name
       |  191| *  and returned \c NULL if the selector was not found. This was changed for safety, because it was
       |  192| *  observed that many of the callers of this function did not check the return value for \c NULL.
       |  193| */
       |  194|OBJC_EXPORT SEL sel_getUid(const char *str)
       |  195|    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
       |  196|
       |  197|typedef const void* objc_objectptr_t;
       |  198|
       |  199|
       |  200|// Obsolete ARC conversions.
       |  201|
       |  202|OBJC_EXPORT id objc_retainedObject(objc_objectptr_t obj)
       |  203|    OBJC_UNAVAILABLE("use CFBridgingRelease() or a (__bridge_transfer id) cast instead");
       |  204|OBJC_EXPORT id objc_unretainedObject(objc_objectptr_t obj)
       |  205|    OBJC_UNAVAILABLE("use a (__bridge id) cast instead");
       |  206|OBJC_EXPORT objc_objectptr_t objc_unretainedPointer(id obj)
       |  207|    OBJC_UNAVAILABLE("use a __bridge cast instead");
       |  208|
       |  209|
       |  210|#if !__OBJC2__
       |  211|
       |  212|// The following declarations are provided here for source compatibility.
       |  213|
       |  214|#if defined(__LP64__)
       |  215|    typedef long arith_t;
       |  216|    typedef unsigned long uarith_t;
       |  217|#   define ARITH_SHIFT 32
       |  218|#else
       |  219|    typedef int arith_t;
       |  220|    typedef unsigned uarith_t;
       |  221|#   define ARITH_SHIFT 16
       |  222|#endif
       |  223|
       |  224|typedef char *STR;
       |  225|
       |  226|#define ISSELECTOR(sel) sel_isMapped(sel)
       |  227|#define SELNAME(sel)	sel_getName(sel)
       |  228|#define SELUID(str)	sel_getUid(str)
       |  229|#define NAMEOF(obj)     object_getClassName(obj)
       |  230|#define IV(obj)         object_getIndexedIvars(obj)
       |  231|
       |  232|#endif
       |  233|
       |  234|#endif  /* _OBJC_OBJC_H_ */

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator10.0.sdk/usr/include/sys/_types.h:
       |    1|/*
       |    2| * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
       |    3| *
       |    4| * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
       |    5| * 
       |    6| * This file contains Original Code and/or Modifications of Original Code
       |    7| * as defined in and that are subject to the Apple Public Source License
       |    8| * Version 2.0 (the 'License'). You may not use this file except in
       |    9| * compliance with the License. The rights granted to you under the License
       |   10| * may not be used to create, or enable the creation or redistribution of,
       |   11| * unlawful or unlicensed copies of an Apple operating system, or to
       |   12| * circumvent, violate, or enable the circumvention or violation of, any
       |   13| * terms of an Apple operating system software license agreement.
       |   14| * 
       |   15| * Please obtain a copy of the License at
       |   16| * http://www.opensource.apple.com/apsl/ and read it before using this file.
       |   17| * 
       |   18| * The Original Code and all software distributed under the License are
       |   19| * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
       |   20| * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
       |   21| * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
       |   22| * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
       |   23| * Please see the License for the specific language governing rights and
       |   24| * limitations under the License.
       |   25| * 
       |   26| * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
       |   27| */
       |   28|
       |   29|#ifndef _SYS__TYPES_H_
       |   30|#define _SYS__TYPES_H_
       |   31|
       |   32|#include <sys/cdefs.h>
       |   33|#include <machine/_types.h>
       |   34|
       |   35|/*
       |   36| * Type definitions; takes common type definitions that must be used
       |   37| * in multiple header files due to [XSI], removes them from the system
       |   38| * space, and puts them in the implementation space.
       |   39| */
       |   40|
       |   41|#ifdef __cplusplus
       |   42|#ifdef __GNUG__
       |   43|#define __DARWIN_NULL __null
       |   44|#else /* ! __GNUG__ */
       |   45|#ifdef __LP64__
       |   46|#define __DARWIN_NULL (0L)
       |   47|#else /* !__LP64__ */
       |   48|#define __DARWIN_NULL 0
       |   49|#endif /* __LP64__ */
       |   50|#endif /* __GNUG__ */
       |   51|#else /* ! __cplusplus */
      0|   52|#define __DARWIN_NULL ((void *)0)
       |   53|#endif /* __cplusplus */
       |   54|
       |   55|typedef	__int64_t	__darwin_blkcnt_t;	/* total blocks */
       |   56|typedef	__int32_t	__darwin_blksize_t;	/* preferred block size */
       |   57|typedef __int32_t	__darwin_dev_t;		/* dev_t */
       |   58|typedef unsigned int	__darwin_fsblkcnt_t;	/* Used by statvfs and fstatvfs */
       |   59|typedef unsigned int	__darwin_fsfilcnt_t;	/* Used by statvfs and fstatvfs */
       |   60|typedef __uint32_t	__darwin_gid_t;		/* [???] process and group IDs */
       |   61|typedef __uint32_t	__darwin_id_t;		/* [XSI] pid_t, uid_t, or gid_t*/
       |   62|typedef __uint64_t	__darwin_ino64_t;	/* [???] Used for 64 bit inodes */
       |   63|#if __DARWIN_64_BIT_INO_T
       |   64|typedef __darwin_ino64_t __darwin_ino_t;	/* [???] Used for inodes */
       |   65|#else /* !__DARWIN_64_BIT_INO_T */
       |   66|typedef __uint32_t	__darwin_ino_t;		/* [???] Used for inodes */
       |   67|#endif /* __DARWIN_64_BIT_INO_T */
       |   68|typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
       |   69|typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
       |   70|typedef __uint16_t	__darwin_mode_t;	/* [???] Some file attributes */
       |   71|typedef __int64_t	__darwin_off_t;		/* [???] Used for file sizes */
       |   72|typedef __int32_t	__darwin_pid_t;		/* [???] process and group IDs */
       |   73|typedef __uint32_t	__darwin_sigset_t;	/* [???] signal set */
       |   74|typedef __int32_t	__darwin_suseconds_t;	/* [???] microseconds */
       |   75|typedef __uint32_t	__darwin_uid_t;		/* [???] user IDs */
       |   76|typedef __uint32_t	__darwin_useconds_t;	/* [???] microseconds */
       |   77|typedef	unsigned char	__darwin_uuid_t[16];
       |   78|typedef	char	__darwin_uuid_string_t[37];
       |   79|
       |   80|#include <sys/_pthread/_pthread_types.h>
       |   81|
       |   82|#if defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 5 || __GNUC__ > 3)
       |   83|#define __offsetof(type, field) __builtin_offsetof(type, field)
       |   84|#else /* !(gcc >= 3.5) */
       |   85|#define __offsetof(type, field) ((size_t)(&((type *)0)->field))
       |   86|#endif /* (gcc >= 3.5) */
       |   87|
       |   88|
       |   89|#endif	/* _SYS__TYPES_H_ */

/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/8.0.0/include/stdarg.h:
       |    1|/*===---- stdarg.h - Variable argument handling ----------------------------===
       |    2| *
       |    3| * Copyright (c) 2008 Eli Friedman
       |    4| *
       |    5| * Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6| * of this software and associated documentation files (the "Software"), to deal
       |    7| * in the Software without restriction, including without limitation the rights
       |    8| * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9| * copies of the Software, and to permit persons to whom the Software is
       |   10| * furnished to do so, subject to the following conditions:
       |   11| *
       |   12| * The above copyright notice and this permission notice shall be included in
       |   13| * all copies or substantial portions of the Software.
       |   14| *
       |   15| * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16| * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17| * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18| * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19| * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20| * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21| * THE SOFTWARE.
       |   22| *
       |   23| *===-----------------------------------------------------------------------===
       |   24| */
       |   25|
       |   26|#ifndef __STDARG_H
       |   27|#define __STDARG_H
       |   28|
       |   29|#ifndef _VA_LIST
       |   30|typedef __builtin_va_list va_list;
       |   31|#define _VA_LIST
       |   32|#endif
      0|   33|#define va_start(ap, param) __builtin_va_start(ap, param)
      0|   34|#define va_end(ap)          __builtin_va_end(ap)
      0|   35|#define va_arg(ap, type)    __builtin_va_arg(ap, type)
       |   36|
       |   37|/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
       |   38| * or -ansi is not specified, since it was not part of C90.
       |   39| */
       |   40|#define __va_copy(d,s) __builtin_va_copy(d,s)
       |   41|
       |   42|#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
       |   43|#define va_copy(dest, src)  __builtin_va_copy(dest, src)
       |   44|#endif
       |   45|
       |   46|/* Hack required to make standard headers work, at least on Ubuntu */
       |   47|#ifndef __GNUC_VA_LIST
       |   48|#define __GNUC_VA_LIST 1
       |   49|#endif
       |   50|typedef __builtin_va_list __gnuc_va_list;
       |   51|
       |   52|#endif /* __STDARG_H */

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/AssertionDispatcher.swift:
       |    1|
       |    2|/// AssertionDispatcher allows multiple AssertionHandlers to receive
       |    3|/// assertion messages.
       |    4|///
       |    5|/// @warning Does not fully dispatch if one of the handlers raises an exception.
       |    6|///          This is possible with XCTest-based assertion handlers.
       |    7|///
       |    8|public class AssertionDispatcher: AssertionHandler {
       |    9|    let handlers: [AssertionHandler]
       |   10|
      0|   11|    public init(handlers: [AssertionHandler]) {
      0|   12|        self.handlers = handlers
      0|   13|    }
       |   14|
      0|   15|    public func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {
      0|   16|        for handler in handlers {
      0|   17|            handler.assert(assertion, message: message, location: location)
      0|   18|        }
      0|   19|    }
       |   20|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/AssertionRecorder.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A data structure that stores information about an assertion when
       |    4|/// AssertionRecorder is set as the Nimble assertion handler.
       |    5|///
       |    6|/// @see AssertionRecorder
       |    7|/// @see AssertionHandler
       |    8|public struct AssertionRecord: CustomStringConvertible {
       |    9|    /// Whether the assertion succeeded or failed
       |   10|    public let success: Bool
       |   11|    /// The failure message the assertion would display on failure.
       |   12|    public let message: FailureMessage
       |   13|    /// The source location the expectation occurred on.
       |   14|    public let location: SourceLocation
       |   15|
      0|   16|    public var description: String {
      0|   17|        return "AssertionRecord { success=\(success), message='\(message.stringValue)', location=\(location) }"
      0|   18|    }
       |   19|}
       |   20|
       |   21|/// An AssertionHandler that silently records assertions that Nimble makes.
       |   22|/// This is useful for testing failure messages for matchers.
       |   23|///
       |   24|/// @see AssertionHandler
       |   25|public class AssertionRecorder : AssertionHandler {
       |   26|    /// All the assertions that were captured by this recorder
       |   27|    public var assertions = [AssertionRecord]()
       |   28|
      0|   29|    public init() {}
       |   30|
      0|   31|    public func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {
      0|   32|        assertions.append(
      0|   33|            AssertionRecord(
      0|   34|                success: assertion,
      0|   35|                message: message,
      0|   36|                location: location))
      0|   37|    }
       |   38|}
       |   39|
       |   40|/// Allows you to temporarily replace the current Nimble assertion handler with
       |   41|/// the one provided for the scope of the closure.
       |   42|///
       |   43|/// Once the closure finishes, then the original Nimble assertion handler is restored.
       |   44|///
       |   45|/// @see AssertionHandler
      0|   46|public func withAssertionHandler(tempAssertionHandler: AssertionHandler, closure: () throws -> Void) {
      0|   47|    let environment = NimbleEnvironment.activeInstance
      0|   48|    let oldRecorder = environment.assertionHandler
      0|   49|    let capturer = NMBExceptionCapture(handler: nil, finally: ({
      0|   50|        environment.assertionHandler = oldRecorder
      0|   51|    }))
      0|   52|    environment.assertionHandler = tempAssertionHandler
      0|   53|    capturer.tryBlock {
      0|   54|        try! closure()
      0|   55|    }
      0|   56|}
       |   57|
       |   58|/// Captures expectations that occur in the given closure. Note that all
       |   59|/// expectations will still go through to the default Nimble handler.
       |   60|///
       |   61|/// This can be useful if you want to gather information about expectations
       |   62|/// that occur within a closure.
       |   63|///
       |   64|/// @param silently expectations are no longer send to the default Nimble 
       |   65|///                 assertion handler when this is true. Defaults to false.
       |   66|///
       |   67|/// @see gatherFailingExpectations
      0|   68|public func gatherExpectations(silently silently: Bool = false, closure: () -> Void) -> [AssertionRecord] {
      0|   69|    let previousRecorder = NimbleEnvironment.activeInstance.assertionHandler
      0|   70|    let recorder = AssertionRecorder()
      0|   71|    let handlers: [AssertionHandler]
      0|   72|
      0|   73|    if silently {
      0|   74|        handlers = [recorder]
      0|   75|    } else {
      0|   76|        handlers = [recorder, previousRecorder]
      0|   77|    }
      0|   78|
      0|   79|    let dispatcher = AssertionDispatcher(handlers: handlers)
      0|   80|    withAssertionHandler(dispatcher, closure: closure)
      0|   81|    return recorder.assertions
      0|   82|}
       |   83|
       |   84|/// Captures failed expectations that occur in the given closure. Note that all
       |   85|/// expectations will still go through to the default Nimble handler.
       |   86|///
       |   87|/// This can be useful if you want to gather information about failed
       |   88|/// expectations that occur within a closure.
       |   89|///
       |   90|/// @param silently expectations are no longer send to the default Nimble
       |   91|///                 assertion handler when this is true. Defaults to false.
       |   92|///
       |   93|/// @see gatherExpectations
       |   94|/// @see raiseException source for an example use case.
      0|   95|public func gatherFailingExpectations(silently silently: Bool = false, closure: () -> Void) -> [AssertionRecord] {
      0|   96|    let assertions = gatherExpectations(silently: silently, closure: closure)
      0|   97|    return assertions.filter { assertion in
      0|   98|        !assertion.success
      0|   99|    }
      0|  100|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/NimbleEnvironment.swift:
       |    1|import Foundation
       |    2|
       |    3|/// "Global" state of Nimble is stored here. Only DSL functions should access / be aware of this
       |    4|/// class' existance
       |    5|internal class NimbleEnvironment {
       |    6|    static var activeInstance: NimbleEnvironment {
     12|    7|        get {
     12|    8|            let env = NSThread.currentThread().threadDictionary["NimbleEnvironment"]
     11|    9|            if let env = env as? NimbleEnvironment {
     11|   10|                return env
      1|   11|            } else {
      1|   12|                let newEnv = NimbleEnvironment()
      1|   13|                self.activeInstance = newEnv
      1|   14|                return newEnv
      0|   15|            }
      0|   16|        }
      1|   17|        set {
      1|   18|            NSThread.currentThread().threadDictionary["NimbleEnvironment"] = newValue
      1|   19|        }
       |   20|    }
       |   21|
       |   22|    // TODO: eventually migrate the global to this environment value
       |   23|    var assertionHandler: AssertionHandler {
     12|   24|        get { return NimbleAssertionHandler }
      0|   25|        set { NimbleAssertionHandler = newValue }
       |   26|    }
       |   27|
       |   28|#if _runtime(_ObjC)
       |   29|    var awaiter: Awaiter
       |   30|
      1|   31|    init() {
      1|   32|        awaiter = Awaiter(
      1|   33|            waitLock: AssertionWaitLock(),
      1|   34|            asyncQueue: dispatch_get_main_queue(),
      1|   35|            timeoutQueue: dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0))
      1|   36|    }
       |   37|#endif
       |   38|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/NimbleXCTestHandler.swift:
       |    1|import Foundation
       |    2|import XCTest
       |    3|
       |    4|/// Default handler for Nimble. This assertion handler passes failures along to
       |    5|/// XCTest.
       |    6|public class NimbleXCTestHandler : AssertionHandler {
     12|    7|    public func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {
      0|    8|        if !assertion {
      0|    9|            recordFailure("\(message.stringValue)\n", location: location)
     12|   10|        }
     12|   11|    }
       |   12|}
       |   13|
       |   14|/// Alternative handler for Nimble. This assertion handler passes failures along
       |   15|/// to XCTest by attempting to reduce the failure message size.
       |   16|public class NimbleShortXCTestHandler: AssertionHandler {
      0|   17|    public func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {
      0|   18|        if !assertion {
      0|   19|            let msg: String
      0|   20|            if let actual = message.actualValue {
      0|   21|                msg = "got: \(actual) \(message.postfixActual)"
      0|   22|            } else {
      0|   23|                msg = "expected \(message.to) \(message.postfixMessage)"
      0|   24|            }
      0|   25|            recordFailure("\(msg)\n", location: location)
      0|   26|        }
      0|   27|    }
       |   28|}
       |   29|
       |   30|/// Fallback handler in case XCTest is unavailable. This assertion handler will abort
       |   31|/// the program if it is invoked.
       |   32|class NimbleXCTestUnavailableHandler : AssertionHandler {
      0|   33|    func assert(assertion: Bool, message: FailureMessage, location: SourceLocation) {
      0|   34|        fatalError("XCTest is not available and no custom assertion handler was configured. Aborting.")
      0|   35|    }
       |   36|}
       |   37|
       |   38|#if _runtime(_ObjC)
       |   39|    /// Helper class providing access to the currently executing XCTestCase instance, if any
       |   40|@objc final internal class CurrentTestCaseTracker: NSObject, XCTestObservation {
       |   41|    @objc static let sharedInstance = CurrentTestCaseTracker()
       |   42|
       |   43|    private(set) var currentTestCase: XCTestCase?
       |   44|
     14|   45|    @objc func testCaseWillStart(testCase: XCTestCase) {
     14|   46|        currentTestCase = testCase
     14|   47|    }
       |   48|
     14|   49|    @objc func testCaseDidFinish(testCase: XCTestCase) {
     14|   50|        currentTestCase = nil
     14|   51|    }
       |   52|}
       |   53|#endif
       |   54|
       |   55|
      1|   56|func isXCTestAvailable() -> Bool {
      1|   57|#if _runtime(_ObjC)
      1|   58|    // XCTest is weakly linked and so may not be present
      1|   59|    return NSClassFromString("XCTestCase") != nil
      1|   60|#else
      1|   61|    return true
      1|   62|#endif
      1|   63|}
       |   64|
      0|   65|private func recordFailure(message: String, location: SourceLocation) {
      0|   66|#if _runtime(_ObjC)
      0|   67|    if let testCase = CurrentTestCaseTracker.sharedInstance.currentTestCase {
      0|   68|        testCase.recordFailureWithDescription(message, inFile: location.file, atLine: location.line, expected: true)
      0|   69|    } else {
      0|   70|        let msg = "Attempted to report a test failure to XCTest while no test case was running. " +
      0|   71|        "The failure was:\n\"\(message)\"\nIt occurred at: \(location.file):\(location.line)"
      0|   72|        NSException(name: NSInternalInconsistencyException, reason: msg, userInfo: nil).raise()
      0|   73|    }
      0|   74|#else
      0|   75|    XCTFail("\(message)\n", file: location.file, line: location.line)
      0|   76|#endif
      0|   77|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/DSL.h:
       |    1|#import <Foundation/Foundation.h>
       |    2|
       |    3|@class NMBExpectation;
       |    4|@class NMBObjCBeCloseToMatcher;
       |    5|@class NMBObjCRaiseExceptionMatcher;
       |    6|@protocol NMBMatcher;
       |    7|
       |    8|
       |    9|#define NIMBLE_EXPORT FOUNDATION_EXPORT
       |   10|
       |   11|#ifdef NIMBLE_DISABLE_SHORT_SYNTAX
       |   12|#define NIMBLE_SHORT(PROTO, ORIGINAL)
       |   13|#else
      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:allPass:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beFalsy:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beAKindOf:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:equal:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:endWith:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:raiseException:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beFalse:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beLessThan:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beGreaterThan:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beEmpty:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:be:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beCloseTo:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:haveCount:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beAnInstanceOf:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beginWith:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beGreaterThanOrEqualTo:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beTruthy:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:match:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beTrue:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beLessThanOrEqualTo:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beNil:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
  | DSL.m:beIdenticalTo:
  |      0|   14|#define NIMBLE_SHORT(PROTO, ORIGINAL) FOUNDATION_STATIC_INLINE PROTO { return (ORIGINAL); }
  ------------------
       |   15|#endif
       |   16|
       |   17|NIMBLE_EXPORT NMBExpectation *NMB_expect(id(^actualBlock)(), NSString *file, NSUInteger line);
       |   18|NIMBLE_EXPORT NMBExpectation *NMB_expectAction(void(^actualBlock)(), NSString *file, NSUInteger line);
       |   19|
       |   20|NIMBLE_EXPORT id<NMBMatcher> NMB_equal(id expectedValue);
       |   21|NIMBLE_SHORT(id<NMBMatcher> equal(id expectedValue),
       |   22|             NMB_equal(expectedValue));
       |   23|
       |   24|NIMBLE_EXPORT id<NMBMatcher> NMB_haveCount(id expectedValue);
       |   25|NIMBLE_SHORT(id<NMBMatcher> haveCount(id expectedValue),
       |   26|             NMB_haveCount(expectedValue));
       |   27|
       |   28|NIMBLE_EXPORT NMBObjCBeCloseToMatcher *NMB_beCloseTo(NSNumber *expectedValue);
       |   29|NIMBLE_SHORT(NMBObjCBeCloseToMatcher *beCloseTo(id expectedValue),
       |   30|             NMB_beCloseTo(expectedValue));
       |   31|
       |   32|NIMBLE_EXPORT id<NMBMatcher> NMB_beAnInstanceOf(Class expectedClass);
       |   33|NIMBLE_SHORT(id<NMBMatcher> beAnInstanceOf(Class expectedClass),
       |   34|             NMB_beAnInstanceOf(expectedClass));
       |   35|
       |   36|NIMBLE_EXPORT id<NMBMatcher> NMB_beAKindOf(Class expectedClass);
       |   37|NIMBLE_SHORT(id<NMBMatcher> beAKindOf(Class expectedClass),
       |   38|             NMB_beAKindOf(expectedClass));
       |   39|
       |   40|NIMBLE_EXPORT id<NMBMatcher> NMB_beginWith(id itemElementOrSubstring);
       |   41|NIMBLE_SHORT(id<NMBMatcher> beginWith(id itemElementOrSubstring),
       |   42|             NMB_beginWith(itemElementOrSubstring));
       |   43|
       |   44|NIMBLE_EXPORT id<NMBMatcher> NMB_beGreaterThan(NSNumber *expectedValue);
       |   45|NIMBLE_SHORT(id<NMBMatcher> beGreaterThan(NSNumber *expectedValue),
       |   46|             NMB_beGreaterThan(expectedValue));
       |   47|
       |   48|NIMBLE_EXPORT id<NMBMatcher> NMB_beGreaterThanOrEqualTo(NSNumber *expectedValue);
       |   49|NIMBLE_SHORT(id<NMBMatcher> beGreaterThanOrEqualTo(NSNumber *expectedValue),
       |   50|             NMB_beGreaterThanOrEqualTo(expectedValue));
       |   51|
       |   52|NIMBLE_EXPORT id<NMBMatcher> NMB_beIdenticalTo(id expectedInstance);
       |   53|NIMBLE_SHORT(id<NMBMatcher> beIdenticalTo(id expectedInstance),
       |   54|             NMB_beIdenticalTo(expectedInstance));
       |   55|
       |   56|NIMBLE_EXPORT id<NMBMatcher> NMB_be(id expectedInstance);
       |   57|NIMBLE_SHORT(id<NMBMatcher> be(id expectedInstance),
       |   58|             NMB_be(expectedInstance));
       |   59|
       |   60|NIMBLE_EXPORT id<NMBMatcher> NMB_beLessThan(NSNumber *expectedValue);
       |   61|NIMBLE_SHORT(id<NMBMatcher> beLessThan(NSNumber *expectedValue),
       |   62|             NMB_beLessThan(expectedValue));
       |   63|
       |   64|NIMBLE_EXPORT id<NMBMatcher> NMB_beLessThanOrEqualTo(NSNumber *expectedValue);
       |   65|NIMBLE_SHORT(id<NMBMatcher> beLessThanOrEqualTo(NSNumber *expectedValue),
       |   66|             NMB_beLessThanOrEqualTo(expectedValue));
       |   67|
       |   68|NIMBLE_EXPORT id<NMBMatcher> NMB_beTruthy(void);
       |   69|NIMBLE_SHORT(id<NMBMatcher> beTruthy(void),
       |   70|             NMB_beTruthy());
       |   71|
       |   72|NIMBLE_EXPORT id<NMBMatcher> NMB_beFalsy(void);
       |   73|NIMBLE_SHORT(id<NMBMatcher> beFalsy(void),
       |   74|             NMB_beFalsy());
       |   75|
       |   76|NIMBLE_EXPORT id<NMBMatcher> NMB_beTrue(void);
       |   77|NIMBLE_SHORT(id<NMBMatcher> beTrue(void),
       |   78|             NMB_beTrue());
       |   79|
       |   80|NIMBLE_EXPORT id<NMBMatcher> NMB_beFalse(void);
       |   81|NIMBLE_SHORT(id<NMBMatcher> beFalse(void),
       |   82|             NMB_beFalse());
       |   83|
       |   84|NIMBLE_EXPORT id<NMBMatcher> NMB_beNil(void);
       |   85|NIMBLE_SHORT(id<NMBMatcher> beNil(void),
       |   86|             NMB_beNil());
       |   87|
       |   88|NIMBLE_EXPORT id<NMBMatcher> NMB_beEmpty(void);
       |   89|NIMBLE_SHORT(id<NMBMatcher> beEmpty(void),
       |   90|             NMB_beEmpty());
       |   91|
       |   92|NIMBLE_EXPORT id<NMBMatcher> NMB_containWithNilTermination(id itemOrSubstring, ...) NS_REQUIRES_NIL_TERMINATION;
       |   93|#define NMB_contain(...) NMB_containWithNilTermination(__VA_ARGS__, nil)
       |   94|#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
       |   95|#define contain(...) NMB_contain(__VA_ARGS__)
       |   96|#endif
       |   97|
       |   98|NIMBLE_EXPORT id<NMBMatcher> NMB_endWith(id itemElementOrSubstring);
       |   99|NIMBLE_SHORT(id<NMBMatcher> endWith(id itemElementOrSubstring),
       |  100|             NMB_endWith(itemElementOrSubstring));
       |  101|
       |  102|NIMBLE_EXPORT NMBObjCRaiseExceptionMatcher *NMB_raiseException(void);
       |  103|NIMBLE_SHORT(NMBObjCRaiseExceptionMatcher *raiseException(void),
       |  104|             NMB_raiseException());
       |  105|
       |  106|NIMBLE_EXPORT id<NMBMatcher> NMB_match(id expectedValue);
       |  107|NIMBLE_SHORT(id<NMBMatcher> match(id expectedValue),
       |  108|             NMB_match(expectedValue));
       |  109|
       |  110|NIMBLE_EXPORT id<NMBMatcher> NMB_allPass(id matcher);
       |  111|NIMBLE_SHORT(id<NMBMatcher> allPass(id matcher),
       |  112|             NMB_allPass(matcher));
       |  113|
       |  114|NIMBLE_EXPORT id<NMBMatcher> NMB_satisfyAnyOfWithMatchers(id matchers);
       |  115|#define NMB_satisfyAnyOf(...) NMB_satisfyAnyOfWithMatchers(@[__VA_ARGS__])
       |  116|#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
       |  117|#define satisfyAnyOf(...) NMB_satisfyAnyOf(__VA_ARGS__)
       |  118|#endif
       |  119|
       |  120|// In order to preserve breakpoint behavior despite using macros to fill in __FILE__ and __LINE__,
       |  121|// define a builder that populates __FILE__ and __LINE__, and returns a block that takes timeout
       |  122|// and action arguments. See https://github.com/Quick/Quick/pull/185 for details.
       |  123|typedef void (^NMBWaitUntilTimeoutBlock)(NSTimeInterval timeout, void (^action)(void (^)(void)));
       |  124|typedef void (^NMBWaitUntilBlock)(void (^action)(void (^)(void)));
       |  125|
       |  126|NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line);
       |  127|
       |  128|NIMBLE_EXPORT NMBWaitUntilTimeoutBlock NMB_waitUntilTimeoutBuilder(NSString *file, NSUInteger line);
       |  129|NIMBLE_EXPORT NMBWaitUntilBlock NMB_waitUntilBuilder(NSString *file, NSUInteger line);
       |  130|
       |  131|NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line);
       |  132|
       |  133|#define NMB_waitUntilTimeout NMB_waitUntilTimeoutBuilder(@(__FILE__), __LINE__)
       |  134|#define NMB_waitUntil NMB_waitUntilBuilder(@(__FILE__), __LINE__)
       |  135|
       |  136|#ifndef NIMBLE_DISABLE_SHORT_SYNTAX
       |  137|#define expect(...) NMB_expect(^id{ return (__VA_ARGS__); }, @(__FILE__), __LINE__)
       |  138|#define expectAction(BLOCK) NMB_expectAction((BLOCK), @(__FILE__), __LINE__)
       |  139|#define failWithMessage(msg) NMB_failWithMessage(msg, @(__FILE__), __LINE__)
       |  140|#define fail() failWithMessage(@"fail() always fails")
       |  141|
       |  142|
       |  143|#define waitUntilTimeout NMB_waitUntilTimeout
       |  144|#define waitUntil NMB_waitUntil
       |  145|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/DSL.m:
       |    1|#import <Nimble/DSL.h>
       |    2|#import <Nimble/Nimble-Swift.h>
       |    3|
       |    4|SWIFT_CLASS("_TtC6Nimble7NMBWait")
       |    5|@interface NMBWait : NSObject
       |    6|
       |    7|+ (void)untilTimeout:(NSTimeInterval)timeout file:(NSString *)file line:(NSUInteger)line action:(void(^)())action;
       |    8|+ (void)untilFile:(NSString *)file line:(NSUInteger)line action:(void(^)())action;
       |    9|
       |   10|@end
       |   11|
      0|   12|NIMBLE_EXPORT NMBExpectation *NMB_expect(id(^actualBlock)(), NSString *file, NSUInteger line) {
      0|   13|    return [[NMBExpectation alloc] initWithActualBlock:actualBlock
      0|   14|                                              negative:NO
      0|   15|                                                  file:file
      0|   16|                                                  line:line];
      0|   17|}
       |   18|
      0|   19|NIMBLE_EXPORT NMBExpectation *NMB_expectAction(void(^actualBlock)(), NSString *file, NSUInteger line) {
      0|   20|    return NMB_expect(^id{
      0|   21|        actualBlock();
      0|   22|        return nil;
      0|   23|    }, file, line);
      0|   24|}
       |   25|
      0|   26|NIMBLE_EXPORT void NMB_failWithMessage(NSString *msg, NSString *file, NSUInteger line) {
      0|   27|    return [NMBExpectation failWithMessage:msg file:file line:line];
      0|   28|}
       |   29|
      0|   30|NIMBLE_EXPORT id<NMBMatcher> NMB_beAnInstanceOf(Class expectedClass) {
      0|   31|    return [NMBObjCMatcher beAnInstanceOfMatcher:expectedClass];
      0|   32|}
       |   33|
      0|   34|NIMBLE_EXPORT id<NMBMatcher> NMB_beAKindOf(Class expectedClass) {
      0|   35|    return [NMBObjCMatcher beAKindOfMatcher:expectedClass];
      0|   36|}
       |   37|
      0|   38|NIMBLE_EXPORT NMBObjCBeCloseToMatcher *NMB_beCloseTo(NSNumber *expectedValue) {
      0|   39|    return [NMBObjCMatcher beCloseToMatcher:expectedValue within:0.001];
      0|   40|}
       |   41|
      0|   42|NIMBLE_EXPORT id<NMBMatcher> NMB_beginWith(id itemElementOrSubstring) {
      0|   43|    return [NMBObjCMatcher beginWithMatcher:itemElementOrSubstring];
      0|   44|}
       |   45|
      0|   46|NIMBLE_EXPORT id<NMBMatcher> NMB_beGreaterThan(NSNumber *expectedValue) {
      0|   47|    return [NMBObjCMatcher beGreaterThanMatcher:expectedValue];
      0|   48|}
       |   49|
      0|   50|NIMBLE_EXPORT id<NMBMatcher> NMB_beGreaterThanOrEqualTo(NSNumber *expectedValue) {
      0|   51|    return [NMBObjCMatcher beGreaterThanOrEqualToMatcher:expectedValue];
      0|   52|}
       |   53|
      0|   54|NIMBLE_EXPORT id<NMBMatcher> NMB_beIdenticalTo(id expectedInstance) {
      0|   55|    return [NMBObjCMatcher beIdenticalToMatcher:expectedInstance];
      0|   56|}
       |   57|
      0|   58|NIMBLE_EXPORT id<NMBMatcher> NMB_be(id expectedInstance) {
      0|   59|    return [NMBObjCMatcher beIdenticalToMatcher:expectedInstance];
      0|   60|}
       |   61|
      0|   62|NIMBLE_EXPORT id<NMBMatcher> NMB_beLessThan(NSNumber *expectedValue) {
      0|   63|    return [NMBObjCMatcher beLessThanMatcher:expectedValue];
      0|   64|}
       |   65|
      0|   66|NIMBLE_EXPORT id<NMBMatcher> NMB_beLessThanOrEqualTo(NSNumber *expectedValue) {
      0|   67|    return [NMBObjCMatcher beLessThanOrEqualToMatcher:expectedValue];
      0|   68|}
       |   69|
      0|   70|NIMBLE_EXPORT id<NMBMatcher> NMB_beTruthy() {
      0|   71|    return [NMBObjCMatcher beTruthyMatcher];
      0|   72|}
       |   73|
      0|   74|NIMBLE_EXPORT id<NMBMatcher> NMB_beFalsy() {
      0|   75|    return [NMBObjCMatcher beFalsyMatcher];
      0|   76|}
       |   77|
      0|   78|NIMBLE_EXPORT id<NMBMatcher> NMB_beTrue() {
      0|   79|    return [NMBObjCMatcher beTrueMatcher];
      0|   80|}
       |   81|
      0|   82|NIMBLE_EXPORT id<NMBMatcher> NMB_beFalse() {
      0|   83|    return [NMBObjCMatcher beFalseMatcher];
      0|   84|}
       |   85|
      0|   86|NIMBLE_EXPORT id<NMBMatcher> NMB_beNil() {
      0|   87|    return [NMBObjCMatcher beNilMatcher];
      0|   88|}
       |   89|
      0|   90|NIMBLE_EXPORT id<NMBMatcher> NMB_beEmpty() {
      0|   91|    return [NMBObjCMatcher beEmptyMatcher];
      0|   92|}
       |   93|
      0|   94|NIMBLE_EXPORT id<NMBMatcher> NMB_containWithNilTermination(id itemOrSubstring, ...) {
      0|   95|    NSMutableArray *itemOrSubstringArray = [NSMutableArray array];
      0|   96|
      0|   97|    if (itemOrSubstring) {
      0|   98|        [itemOrSubstringArray addObject:itemOrSubstring];
      0|   99|
      0|  100|        va_list args;
      0|  101|        va_start(args, itemOrSubstring);
      0|  102|        id next;
      0|  103|        while ((next = va_arg(args, id))) {
      0|  104|            [itemOrSubstringArray addObject:next];
      0|  105|        }
      0|  106|        va_end(args);
      0|  107|    }
      0|  108|
      0|  109|    return [NMBObjCMatcher containMatcher:itemOrSubstringArray];
      0|  110|}
       |  111|
      0|  112|NIMBLE_EXPORT id<NMBMatcher> NMB_endWith(id itemElementOrSubstring) {
      0|  113|    return [NMBObjCMatcher endWithMatcher:itemElementOrSubstring];
      0|  114|}
       |  115|
      0|  116|NIMBLE_EXPORT id<NMBMatcher> NMB_equal(id expectedValue) {
      0|  117|    return [NMBObjCMatcher equalMatcher:expectedValue];
      0|  118|}
       |  119|
      0|  120|NIMBLE_EXPORT id<NMBMatcher> NMB_haveCount(id expectedValue) {
      0|  121|    return [NMBObjCMatcher haveCountMatcher:expectedValue];
      0|  122|}
       |  123|
      0|  124|NIMBLE_EXPORT id<NMBMatcher> NMB_match(id expectedValue) {
      0|  125|    return [NMBObjCMatcher matchMatcher:expectedValue];
      0|  126|}
       |  127|
      0|  128|NIMBLE_EXPORT id<NMBMatcher> NMB_allPass(id expectedValue) {
      0|  129|    return [NMBObjCMatcher allPassMatcher:expectedValue];
      0|  130|}
       |  131|
      0|  132|NIMBLE_EXPORT id<NMBMatcher> NMB_satisfyAnyOfWithMatchers(id matchers) {
      0|  133|    return [NMBObjCMatcher satisfyAnyOfMatcher:matchers];
      0|  134|}
       |  135|
      0|  136|NIMBLE_EXPORT NMBObjCRaiseExceptionMatcher *NMB_raiseException() {
      0|  137|    return [NMBObjCMatcher raiseExceptionMatcher];
      0|  138|}
       |  139|
      0|  140|NIMBLE_EXPORT NMBWaitUntilTimeoutBlock NMB_waitUntilTimeoutBuilder(NSString *file, NSUInteger line) {
      0|  141|    return ^(NSTimeInterval timeout, void (^action)(void (^)(void))) {
      0|  142|        [NMBWait untilTimeout:timeout file:file line:line action:action];
      0|  143|    };
      0|  144|}
       |  145|
      0|  146|NIMBLE_EXPORT NMBWaitUntilBlock NMB_waitUntilBuilder(NSString *file, NSUInteger line) {
      0|  147|  return ^(void (^action)(void (^)(void))) {
      0|  148|    [NMBWait untilFile:file line:line action:action];
      0|  149|  };
      0|  150|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/NMBExceptionCapture.m:
       |    1|#import "NMBExceptionCapture.h"
       |    2|
       |    3|@interface NMBExceptionCapture ()
       |    4|@property (nonatomic, copy) void(^handler)(NSException *exception);
       |    5|@property (nonatomic, copy) void(^finally)();
       |    6|@end
       |    7|
       |    8|@implementation NMBExceptionCapture
       |    9|
      0|   10|- (id)initWithHandler:(void(^)(NSException *))handler finally:(void(^)())finally {
      0|   11|    self = [super init];
      0|   12|    if (self) {
      0|   13|        self.handler = handler;
      0|   14|        self.finally = finally;
      0|   15|    }
      0|   16|    return self;
      0|   17|}
       |   18|
      0|   19|- (void)tryBlock:(void(^)())unsafeBlock {
      0|   20|    @try {
      0|   21|        unsafeBlock();
      0|   22|    }
      0|   23|    @catch (NSException *exception) {
      0|   24|        if (self.handler) {
      0|   25|            self.handler(exception);
      0|   26|        }
      0|   27|    }
      0|   28|    @finally {
      0|   29|        if (self.finally) {
      0|   30|            self.finally();
      0|   31|        }
      0|   32|    }
      0|   33|}
       |   34|
       |   35|@end

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/NMBExpectation.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|
       |    5|internal struct ObjCMatcherWrapper : Matcher {
       |    6|    let matcher: NMBMatcher
       |    7|
      0|    8|    func matches(actualExpression: Expression<NSObject>, failureMessage: FailureMessage) -> Bool {
      0|    9|        return matcher.matches(
      0|   10|            ({ try! actualExpression.evaluate() }),
      0|   11|            failureMessage: failureMessage,
      0|   12|            location: actualExpression.location)
      0|   13|    }
       |   14|
      0|   15|    func doesNotMatch(actualExpression: Expression<NSObject>, failureMessage: FailureMessage) -> Bool {
      0|   16|        return matcher.doesNotMatch(
      0|   17|            ({ try! actualExpression.evaluate() }),
      0|   18|            failureMessage: failureMessage,
      0|   19|            location: actualExpression.location)
      0|   20|    }
       |   21|}
       |   22|
       |   23|// Equivalent to Expectation, but for Nimble's Objective-C interface
       |   24|public class NMBExpectation : NSObject {
       |   25|    internal let _actualBlock: () -> NSObject!
       |   26|    internal var _negative: Bool
       |   27|    internal let _file: FileString
       |   28|    internal let _line: UInt
       |   29|    internal var _timeout: NSTimeInterval = 1.0
       |   30|
      0|   31|    public init(actualBlock: () -> NSObject!, negative: Bool, file: FileString, line: UInt) {
      0|   32|        self._actualBlock = actualBlock
      0|   33|        self._negative = negative
      0|   34|        self._file = file
      0|   35|        self._line = line
      0|   36|    }
       |   37|
      0|   38|    private var expectValue: Expectation<NSObject> {
      0|   39|        return expect(_file, line: _line){
      0|   40|            self._actualBlock() as NSObject?
      0|   41|        }
      0|   42|    }
       |   43|
      0|   44|    public var withTimeout: (NSTimeInterval) -> NMBExpectation {
      0|   45|        return ({ timeout in self._timeout = timeout
      0|   46|            return self
      0|   47|        })
      0|   48|    }
       |   49|
      0|   50|    public var to: (NMBMatcher) -> Void {
      0|   51|        return ({ matcher in
      0|   52|            self.expectValue.to(ObjCMatcherWrapper(matcher: matcher))
      0|   53|        })
      0|   54|    }
       |   55|
      0|   56|    public var toWithDescription: (NMBMatcher, String) -> Void {
      0|   57|        return ({ matcher, description in
      0|   58|            self.expectValue.to(ObjCMatcherWrapper(matcher: matcher), description: description)
      0|   59|        })
      0|   60|    }
       |   61|
      0|   62|    public var toNot: (NMBMatcher) -> Void {
      0|   63|        return ({ matcher in
      0|   64|            self.expectValue.toNot(
      0|   65|                ObjCMatcherWrapper(matcher: matcher)
      0|   66|            )
      0|   67|        })
      0|   68|    }
       |   69|
      0|   70|    public var toNotWithDescription: (NMBMatcher, String) -> Void {
      0|   71|        return ({ matcher, description in
      0|   72|            self.expectValue.toNot(
      0|   73|                ObjCMatcherWrapper(matcher: matcher), description: description
      0|   74|            )
      0|   75|        })
      0|   76|    }
       |   77|
      0|   78|    public var notTo: (NMBMatcher) -> Void { return toNot }
       |   79|
      0|   80|    public var notToWithDescription: (NMBMatcher, String) -> Void { return toNotWithDescription }
       |   81|
      0|   82|    public var toEventually: (NMBMatcher) -> Void {
      0|   83|        return ({ matcher in
      0|   84|            self.expectValue.toEventually(
      0|   85|                ObjCMatcherWrapper(matcher: matcher),
      0|   86|                timeout: self._timeout,
      0|   87|                description: nil
      0|   88|            )
      0|   89|        })
      0|   90|    }
       |   91|
      0|   92|    public var toEventuallyWithDescription: (NMBMatcher, String) -> Void {
      0|   93|        return ({ matcher, description in
      0|   94|            self.expectValue.toEventually(
      0|   95|                ObjCMatcherWrapper(matcher: matcher),
      0|   96|                timeout: self._timeout,
      0|   97|                description: description
      0|   98|            )
      0|   99|        })
      0|  100|    }
       |  101|
      0|  102|    public var toEventuallyNot: (NMBMatcher) -> Void {
      0|  103|        return ({ matcher in
      0|  104|            self.expectValue.toEventuallyNot(
      0|  105|                ObjCMatcherWrapper(matcher: matcher),
      0|  106|                timeout: self._timeout,
      0|  107|                description: nil
      0|  108|            )
      0|  109|        })
      0|  110|    }
       |  111|
      0|  112|    public var toEventuallyNotWithDescription: (NMBMatcher, String) -> Void {
      0|  113|        return ({ matcher, description in
      0|  114|            self.expectValue.toEventuallyNot(
      0|  115|                ObjCMatcherWrapper(matcher: matcher),
      0|  116|                timeout: self._timeout,
      0|  117|                description: description
      0|  118|            )
      0|  119|        })
      0|  120|    }
       |  121|
      0|  122|    public var toNotEventually: (NMBMatcher) -> Void { return toEventuallyNot }
       |  123|
      0|  124|    public var toNotEventuallyWithDescription: (NMBMatcher, String) -> Void { return toEventuallyNotWithDescription }
       |  125|
      0|  126|    public class func failWithMessage(message: String, file: FileString, line: UInt) {
      0|  127|        fail(message, location: SourceLocation(file: file, line: line))
      0|  128|    }
       |  129|}
       |  130|
       |  131|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/NMBObjCMatcher.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|
       |    5|public typealias MatcherBlock = (actualExpression: Expression<NSObject>, failureMessage: FailureMessage) -> Bool
       |    6|public typealias FullMatcherBlock = (actualExpression: Expression<NSObject>, failureMessage: FailureMessage, shouldNotMatch: Bool) -> Bool
       |    7|
       |    8|public class NMBObjCMatcher : NSObject, NMBMatcher {
       |    9|    let _match: MatcherBlock
       |   10|    let _doesNotMatch: MatcherBlock
       |   11|    let canMatchNil: Bool
       |   12|
      0|   13|    public init(canMatchNil: Bool, matcher: MatcherBlock, notMatcher: MatcherBlock) {
      0|   14|        self.canMatchNil = canMatchNil
      0|   15|        self._match = matcher
      0|   16|        self._doesNotMatch = notMatcher
      0|   17|    }
       |   18|
      0|   19|    public convenience init(matcher: MatcherBlock) {
      0|   20|        self.init(canMatchNil: true, matcher: matcher)
      0|   21|    }
       |   22|
      0|   23|    public convenience init(canMatchNil: Bool, matcher: MatcherBlock) {
      0|   24|        self.init(canMatchNil: canMatchNil, matcher: matcher, notMatcher: ({ actualExpression, failureMessage in
      0|   25|            return !matcher(actualExpression: actualExpression, failureMessage: failureMessage)
      0|   26|        }))
      0|   27|    }
       |   28|
      0|   29|    public convenience init(matcher: FullMatcherBlock) {
      0|   30|        self.init(canMatchNil: true, matcher: matcher)
      0|   31|    }
       |   32|
      0|   33|    public convenience init(canMatchNil: Bool, matcher: FullMatcherBlock) {
      0|   34|        self.init(canMatchNil: canMatchNil, matcher: ({ actualExpression, failureMessage in
      0|   35|            return matcher(actualExpression: actualExpression, failureMessage: failureMessage, shouldNotMatch: false)
      0|   36|        }), notMatcher: ({ actualExpression, failureMessage in
      0|   37|            return matcher(actualExpression: actualExpression, failureMessage: failureMessage, shouldNotMatch: true)
      0|   38|        }))
      0|   39|    }
       |   40|
      0|   41|    private func canMatch(actualExpression: Expression<NSObject>, failureMessage: FailureMessage) -> Bool {
      0|   42|        do {
      0|   43|            if !canMatchNil {
      0|   44|                if try actualExpression.evaluate() == nil {
      0|   45|                    failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   46|                    return false
      0|   47|                }
      0|   48|            }
      0|   49|        } catch let error {
      0|   50|            failureMessage.actualValue = "an unexpected error thrown: \(error)"
      0|   51|            return false
      0|   52|        }
      0|   53|        return true
      0|   54|    }
       |   55|
      0|   56|    public func matches(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|   57|        let expr = Expression(expression: actualBlock, location: location)
      0|   58|        let result = _match(
      0|   59|            actualExpression: expr,
      0|   60|            failureMessage: failureMessage)
      0|   61|        if self.canMatch(Expression(expression: actualBlock, location: location), failureMessage: failureMessage) {
      0|   62|            return result
      0|   63|        } else {
      0|   64|            return false
      0|   65|        }
      0|   66|    }
       |   67|
      0|   68|    public func doesNotMatch(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|   69|        let expr = Expression(expression: actualBlock, location: location)
      0|   70|        let result = _doesNotMatch(
      0|   71|            actualExpression: expr,
      0|   72|            failureMessage: failureMessage)
      0|   73|        if self.canMatch(Expression(expression: actualBlock, location: location), failureMessage: failureMessage) {
      0|   74|            return result
      0|   75|        } else {
      0|   76|            return false
      0|   77|        }
      0|   78|    }
       |   79|}
       |   80|
       |   81|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/NMBStringify.m:
       |    1|#import "NMBStringify.h"
       |    2|#import <Nimble/Nimble-Swift.h>
       |    3|
      0|    4|NSString *_Nonnull NMBStringify(id _Nullable anyObject) {
      0|    5|    return [NMBStringer stringify:anyObject];
      0|    6|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Adapters/ObjectiveC/XCTestObservationCenter+Register.m:
       |    1|#import "CurrentTestCaseTracker.h"
       |    2|#import <XCTest/XCTest.h>
       |    3|#import <objc/runtime.h>
       |    4|
       |    5|#pragma mark - Method Swizzling
       |    6|
       |    7|/// Swaps the implementations between two instance methods.
       |    8|///
       |    9|/// @param class               The class containing `originalSelector`.
       |   10|/// @param originalSelector    Original method to replace.
       |   11|/// @param replacementSelector Replacement method.
      1|   12|void swizzleSelectors(Class class, SEL originalSelector, SEL replacementSelector) {
      1|   13|    Method originalMethod = class_getInstanceMethod(class, originalSelector);
      1|   14|    Method replacementMethod = class_getInstanceMethod(class, replacementSelector);
      1|   15|
      1|   16|    BOOL didAddMethod =
      1|   17|    class_addMethod(class,
      1|   18|                    originalSelector,
      1|   19|                    method_getImplementation(replacementMethod),
      1|   20|                    method_getTypeEncoding(replacementMethod));
      1|   21|
      1|   22|    if (didAddMethod) {
      0|   23|        class_replaceMethod(class,
      0|   24|                            replacementSelector,
      0|   25|                            method_getImplementation(originalMethod),
      0|   26|                            method_getTypeEncoding(originalMethod));
      1|   27|    } else {
      1|   28|        method_exchangeImplementations(originalMethod, replacementMethod);
      1|   29|    }
      1|   30|}
       |   31|
       |   32|#pragma mark - Private
       |   33|
       |   34|@interface XCTestObservationCenter (Private)
       |   35|- (void)_addLegacyTestObserver:(id)observer;
       |   36|@end
       |   37|
       |   38|@implementation XCTestObservationCenter (Register)
       |   39|
       |   40|/// Uses objc method swizzling to register `CurrentTestCaseTracker` as a test observer. This is necessary
       |   41|/// because Xcode 7.3 introduced timing issues where if a custom `XCTestObservation` is registered too early
       |   42|/// it suppresses all console output (generated by `XCTestLog`), breaking any tools that depend on this output.
       |   43|/// This approach waits to register our custom test observer until XCTest adds its first "legacy" observer,
       |   44|/// falling back to registering after the first normal observer if this private method ever changes.
      1|   45|+ (void)load {
      1|   46|    if (class_getInstanceMethod([self class], @selector(_addLegacyTestObserver:))) {
      0|   47|        // Swizzle -_addLegacyTestObserver:
      0|   48|        swizzleSelectors([self class], @selector(_addLegacyTestObserver:), @selector(NMB_original__addLegacyTestObserver:));
      1|   49|    } else {
      1|   50|        // Swizzle -addTestObserver:, only if -_addLegacyTestObserver: is not implemented
      1|   51|        swizzleSelectors([self class], @selector(addTestObserver:), @selector(NMB_original_addTestObserver:));
      1|   52|    }
      1|   53|}
       |   54|
       |   55|#pragma mark - Replacement Methods
       |   56|
       |   57|/// Registers `CurrentTestCaseTracker` as a test observer after `XCTestLog` has been added.
      0|   58|- (void)NMB_original__addLegacyTestObserver:(id)observer {
      0|   59|    [self NMB_original__addLegacyTestObserver:observer];
      0|   60|
      0|   61|    static dispatch_once_t onceToken;
      0|   62|    dispatch_once(&onceToken, ^{
      0|   63|        [self addTestObserver:[CurrentTestCaseTracker sharedInstance]];
      0|   64|    });
      0|   65|}
       |   66|
       |   67|/// Registers `CurrentTestCaseTracker` as a test observer after `XCTestLog` has been added.
       |   68|/// This method is only used if `-_addLegacyTestObserver:` is not impelemented. (added in Xcode 7.3)
      2|   69|- (void)NMB_original_addTestObserver:(id<XCTestObservation>)observer {
      2|   70|    [self NMB_original_addTestObserver:observer];
      2|   71|
      2|   72|    static dispatch_once_t onceToken;
      2|   73|    dispatch_once(&onceToken, ^{
      1|   74|        [self NMB_original_addTestObserver:[CurrentTestCaseTracker sharedInstance]];
      1|   75|    });
      2|   76|}
       |   77|
       |   78|@end

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/DSL+Wait.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|private enum ErrorResult {
       |    5|    case Exception(NSException)
       |    6|    case Error(ErrorType)
       |    7|    case None
       |    8|}
       |    9|
       |   10|/// Only classes, protocols, methods, properties, and subscript declarations can be
       |   11|/// bridges to Objective-C via the @objc keyword. This class encapsulates callback-style
       |   12|/// asynchronous waiting logic so that it may be called from Objective-C and Swift.
       |   13|internal class NMBWait: NSObject {
       |   14|    internal class func until(
       |   15|        timeout timeout: NSTimeInterval,
       |   16|        file: FileString = #file,
       |   17|        line: UInt = #line,
      0|   18|        action: (() -> Void) -> Void) -> Void {
      0|   19|            return throwableUntil(timeout: timeout, file: file, line: line) { (done: () -> Void) throws -> Void in
      0|   20|                action() { done() }
      0|   21|            }
      0|   22|    }
       |   23|
       |   24|    // Using a throwable closure makes this method not objc compatible.
       |   25|    internal class func throwableUntil(
       |   26|        timeout timeout: NSTimeInterval,
       |   27|        file: FileString = #file,
       |   28|        line: UInt = #line,
      0|   29|        action: (() -> Void) throws -> Void) -> Void {
      0|   30|            let awaiter = NimbleEnvironment.activeInstance.awaiter
      0|   31|            let leeway = timeout / 2.0
      0|   32|            let result = awaiter.performBlock { (done: (ErrorResult) -> Void) throws -> Void in
      0|   33|                dispatch_async(dispatch_get_main_queue()) {
      0|   34|                    let capture = NMBExceptionCapture(
      0|   35|                        handler: ({ exception in
      0|   36|                            done(.Exception(exception))
      0|   37|                        }),
      0|   38|                        finally: ({ })
      0|   39|                    )
      0|   40|                    capture.tryBlock {
      0|   41|                        do {
      0|   42|                            try action() {
      0|   43|                                done(.None)
      0|   44|                            }
      0|   45|                        } catch let e {
      0|   46|                            done(.Error(e))
      0|   47|                        }
      0|   48|                    }
      0|   49|                }
      0|   50|            }.timeout(timeout, forcefullyAbortTimeout: leeway).wait("waitUntil(...)", file: file, line: line)
      0|   51|
      0|   52|            switch result {
      0|   53|            case .Incomplete: internalError("Reached .Incomplete state for waitUntil(...).")
      0|   54|            case .BlockedRunLoop:
      0|   55|                fail(blockedRunLoopErrorMessageFor("-waitUntil()", leeway: leeway),
      0|   56|                    file: file, line: line)
      0|   57|            case .TimedOut:
      0|   58|                let pluralize = (timeout == 1 ? "" : "s")
      0|   59|                fail("Waited more than \(timeout) second\(pluralize)", file: file, line: line)
      0|   60|            case let .RaisedException(exception):
      0|   61|                fail("Unexpected exception raised: \(exception)")
      0|   62|            case let .ErrorThrown(error):
      0|   63|                fail("Unexpected error thrown: \(error)")
      0|   64|            case .Completed(.Exception(let exception)):
      0|   65|                fail("Unexpected exception raised: \(exception)")
      0|   66|            case .Completed(.Error(let error)):
      0|   67|                fail("Unexpected error thrown: \(error)")
      0|   68|            case .Completed(.None): // success
      0|   69|                break
      0|   70|            }
      0|   71|    }
       |   72|
       |   73|    @objc(untilFile:line:action:)
      0|   74|    internal class func until(file: FileString = #file, line: UInt = #line, action: (() -> Void) -> Void) -> Void {
      0|   75|        until(timeout: 1, file: file, line: line, action: action)
      0|   76|    }
       |   77|}
       |   78|
      0|   79|internal func blockedRunLoopErrorMessageFor(fnName: String, leeway: NSTimeInterval) -> String {
      0|   80|    return "\(fnName) timed out but was unable to run the timeout handler because the main thread is unresponsive (\(leeway) seconds is allow after the wait times out). Conditions that may cause this include processing blocking IO on the main thread, calls to sleep(), deadlocks, and synchronous IPC. Nimble forcefully stopped run loop which may cause future failures in test run."
      0|   81|}
       |   82|
       |   83|/// Wait asynchronously until the done closure is called or the timeout has been reached.
       |   84|///
       |   85|/// @discussion
       |   86|/// Call the done() closure to indicate the waiting has completed.
       |   87|/// 
       |   88|/// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
       |   89|/// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
      0|   90|public func waitUntil(timeout timeout: NSTimeInterval = 1, file: FileString = #file, line: UInt = #line, action: (() -> Void) -> Void) -> Void {
      0|   91|    NMBWait.until(timeout: timeout, file: file, line: line, action: action)
      0|   92|}
       |   93|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/DSL.swift:
       |    1|import Foundation
       |    2|
       |    3|/// Make an expectation on a given actual value. The value given is lazily evaluated.
       |    4|@warn_unused_result(message="Follow 'expect(â€¦)' with '.to(â€¦)', '.toNot(â€¦)', 'toEventually(â€¦)', '==', etc.")
     12|    5|public func expect<T>(@autoclosure(escaping) expression: () throws -> T?, file: FileString = #file, line: UInt = #line) -> Expectation<T> {
     12|    6|    return Expectation(
     12|    7|        expression: Expression(
     12|    8|            expression: expression,
     12|    9|            location: SourceLocation(file: file, line: line),
     12|   10|            isClosure: true))
     12|   11|}
       |   12|
       |   13|/// Make an expectation on a given actual value. The closure is lazily invoked.
       |   14|@warn_unused_result(message="Follow 'expect(â€¦)' with '.to(â€¦)', '.toNot(â€¦)', 'toEventually(â€¦)', '==', etc.")
      0|   15|public func expect<T>(file: FileString = #file, line: UInt = #line, expression: () throws -> T?) -> Expectation<T> {
      0|   16|    return Expectation(
      0|   17|        expression: Expression(
      0|   18|            expression: expression,
      0|   19|            location: SourceLocation(file: file, line: line),
      0|   20|            isClosure: true))
      0|   21|}
       |   22|
       |   23|/// Always fails the test with a message and a specified location.
      0|   24|public func fail(message: String, location: SourceLocation) {
      0|   25|    let handler = NimbleEnvironment.activeInstance.assertionHandler
      0|   26|    handler.assert(false, message: FailureMessage(stringValue: message), location: location)
      0|   27|}
       |   28|
       |   29|/// Always fails the test with a message.
      0|   30|public func fail(message: String, file: FileString = #file, line: UInt = #line) {
      0|   31|    fail(message, location: SourceLocation(file: file, line: line))
      0|   32|}
       |   33|
       |   34|/// Always fails the test.
      0|   35|public func fail(file: FileString = #file, line: UInt = #line) {
      0|   36|    fail("fail() always fails", file: file, line: line)
      0|   37|}
       |   38|
       |   39|/// Like Swift's precondition(), but raises NSExceptions instead of sigaborts
       |   40|internal func nimblePrecondition(
       |   41|    @autoclosure expr: () -> Bool,
       |   42|    @autoclosure _ name: () -> String,
       |   43|    @autoclosure _ message: () -> String,
       |   44|    file: StaticString = #file,
      0|   45|    line: UInt = #line) -> Bool {
      0|   46|        let result = expr()
      0|   47|        if !result {
      0|   48|#if _runtime(_ObjC)
      0|   49|            let e = NSException(
      0|   50|                name: name(),
      0|   51|                reason: message(),
      0|   52|                userInfo: nil)
      0|   53|            e.raise()
      0|   54|#else
      0|   55|            preconditionFailure("\(name()) - \(message())", file: file, line: line)
      0|   56|#endif
      0|   57|        }
      0|   58|        return result
      0|   59|}
       |   60|
       |   61|@noreturn
      0|   62|internal func internalError(msg: String, file: FileString = #file, line: UInt = #line) {
      0|   63|    fatalError(
      0|   64|        "Nimble Bug Found: \(msg) at \(file):\(line).\n" +
      0|   65|        "Please file a bug to Nimble: https://github.com/Quick/Nimble/issues with the " +
      0|   66|        "code snippet that caused this error."
      0|   67|    )
      0|   68|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Expectation.swift:
       |    1|import Foundation
       |    2|
     12|    3|internal func expressionMatches<T, U where U: Matcher, U.ValueType == T>(expression: Expression<T>, matcher: U, to: String, description: String?) -> (Bool, FailureMessage) {
     12|    4|    let msg = FailureMessage()
     12|    5|    msg.userDescription = description
     12|    6|    msg.to = to
     12|    7|    do {
     12|    8|        let pass = try matcher.matches(expression, failureMessage: msg)
     12|    9|        if msg.actualValue == "" {
     12|   10|            msg.actualValue = "<\(stringify(try expression.evaluate()))>"
     12|   11|        }
     12|   12|        return (pass, msg)
      0|   13|    } catch let error {
      0|   14|        msg.actualValue = "an unexpected error thrown: <\(error)>"
      0|   15|        return (false, msg)
      0|   16|    }
      0|   17|}
       |   18|
      0|   19|internal func expressionDoesNotMatch<T, U where U: Matcher, U.ValueType == T>(expression: Expression<T>, matcher: U, toNot: String, description: String?) -> (Bool, FailureMessage) {
      0|   20|    let msg = FailureMessage()
      0|   21|    msg.userDescription = description
      0|   22|    msg.to = toNot
      0|   23|    do {
      0|   24|        let pass = try matcher.doesNotMatch(expression, failureMessage: msg)
      0|   25|        if msg.actualValue == "" {
      0|   26|            msg.actualValue = "<\(stringify(try expression.evaluate()))>"
      0|   27|        }
      0|   28|        return (pass, msg)
      0|   29|    } catch let error {
      0|   30|        msg.actualValue = "an unexpected error thrown: <\(error)>"
      0|   31|        return (false, msg)
      0|   32|    }
      0|   33|}
       |   34|
       |   35|public struct Expectation<T> {
       |   36|
       |   37|    public let expression: Expression<T>
       |   38|
     12|   39|    public func verify(pass: Bool, _ message: FailureMessage) {
     12|   40|        let handler = NimbleEnvironment.activeInstance.assertionHandler
     12|   41|        handler.assert(pass, message: message, location: expression.location)
     12|   42|    }
       |   43|
       |   44|    /// Tests the actual value using a matcher to match.
     12|   45|    public func to<U where U: Matcher, U.ValueType == T>(matcher: U, description: String? = nil) {
     12|   46|        let (pass, msg) = expressionMatches(expression, matcher: matcher, to: "to", description: description)
     12|   47|        verify(pass, msg)
     12|   48|    }
       |   49|
       |   50|    /// Tests the actual value using a matcher to not match.
      0|   51|    public func toNot<U where U: Matcher, U.ValueType == T>(matcher: U, description: String? = nil) {
      0|   52|        let (pass, msg) = expressionDoesNotMatch(expression, matcher: matcher, toNot: "to not", description: description)
      0|   53|        verify(pass, msg)
      0|   54|    }
       |   55|
       |   56|    /// Tests the actual value using a matcher to not match.
       |   57|    ///
       |   58|    /// Alias to toNot().
      0|   59|    public func notTo<U where U: Matcher, U.ValueType == T>(matcher: U, description: String? = nil) {
      0|   60|        toNot(matcher, description: description)
      0|   61|    }
       |   62|
       |   63|    // see:
       |   64|    // - AsyncMatcherWrapper for extension
       |   65|    // - NMBExpectation for Objective-C interface
       |   66|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Expression.swift:
       |    1|import Foundation
       |    2|
       |    3|// Memoizes the given closure, only calling the passed
       |    4|// closure once; even if repeat calls to the returned closure
     12|    5|internal func memoizedClosure<T>(closure: () throws -> T) -> (Bool) throws -> T {
     12|    6|    var cache: T?
     36|    7|    return ({ withoutCaching in
     36|    8|        if (withoutCaching || cache == nil) {
     12|    9|            cache = try closure()
     36|   10|        }
     36|   11|        return cache!
     36|   12|    })
     12|   13|}
       |   14|
       |   15|/// Expression represents the closure of the value inside expect(...).
       |   16|/// Expressions are memoized by default. This makes them safe to call
       |   17|/// evaluate() multiple times without causing a re-evaluation of the underlying
       |   18|/// closure.
       |   19|///
       |   20|/// @warning Since the closure can be any code, Objective-C code may choose
       |   21|///          to raise an exception. Currently, Expression does not memoize
       |   22|///          exception raising.
       |   23|///
       |   24|/// This provides a common consumable API for matchers to utilize to allow
       |   25|/// Nimble to change internals to how the captured closure is managed.
       |   26|public struct Expression<T> {
       |   27|    internal let _expression: (Bool) throws -> T?
       |   28|    internal let _withoutCaching: Bool
       |   29|    public let location: SourceLocation
       |   30|    public let isClosure: Bool
       |   31|
       |   32|    /// Creates a new expression struct. Normally, expect(...) will manage this
       |   33|    /// creation process. The expression is memoized.
       |   34|    ///
       |   35|    /// @param expression The closure that produces a given value.
       |   36|    /// @param location The source location that this closure originates from.
       |   37|    /// @param isClosure A bool indicating if the captured expression is a
       |   38|    ///                  closure or internally produced closure. Some matchers
       |   39|    ///                  may require closures. For example, toEventually()
       |   40|    ///                  requires an explicit closure. This gives Nimble
       |   41|    ///                  flexibility if @autoclosure behavior changes between
       |   42|    ///                  Swift versions. Nimble internals always sets this true.
     12|   43|    public init(expression: () throws -> T?, location: SourceLocation, isClosure: Bool = true) {
     12|   44|        self._expression = memoizedClosure(expression)
     12|   45|        self.location = location
     12|   46|        self._withoutCaching = false
     12|   47|        self.isClosure = isClosure
     12|   48|    }
       |   49|
       |   50|    /// Creates a new expression struct. Normally, expect(...) will manage this
       |   51|    /// creation process.
       |   52|    ///
       |   53|    /// @param expression The closure that produces a given value.
       |   54|    /// @param location The source location that this closure originates from.
       |   55|    /// @param withoutCaching Indicates if the struct should memoize the given
       |   56|    ///                       closure's result. Subsequent evaluate() calls will
       |   57|    ///                       not call the given closure if this is true.
       |   58|    /// @param isClosure A bool indicating if the captured expression is a
       |   59|    ///                  closure or internally produced closure. Some matchers
       |   60|    ///                  may require closures. For example, toEventually()
       |   61|    ///                  requires an explicit closure. This gives Nimble
       |   62|    ///                  flexibility if @autoclosure behavior changes between
       |   63|    ///                  Swift versions. Nimble internals always sets this true.
      0|   64|    public init(memoizedExpression: (Bool) throws -> T?, location: SourceLocation, withoutCaching: Bool, isClosure: Bool = true) {
      0|   65|        self._expression = memoizedExpression
      0|   66|        self.location = location
      0|   67|        self._withoutCaching = withoutCaching
      0|   68|        self.isClosure = isClosure
      0|   69|    }
       |   70|
       |   71|    /// Returns a new Expression from the given expression. Identical to a map()
       |   72|    /// on this type. This should be used only to typecast the Expression's
       |   73|    /// closure value.
       |   74|    ///
       |   75|    /// The returned expression will preserve location and isClosure.
       |   76|    ///
       |   77|    /// @param block The block that can cast the current Expression value to a
       |   78|    ///              new type.
      0|   79|    public func cast<U>(block: (T?) throws -> U?) -> Expression<U> {
      0|   80|        return Expression<U>(expression: ({ try block(self.evaluate()) }), location: self.location, isClosure: self.isClosure)
      0|   81|    }
       |   82|
     36|   83|    public func evaluate() throws -> T? {
     36|   84|        return try self._expression(_withoutCaching)
     36|   85|    }
       |   86|
      0|   87|    public func withoutCaching() -> Expression<T> {
      0|   88|        return Expression(memoizedExpression: self._expression, location: location, withoutCaching: true, isClosure: isClosure)
      0|   89|    }
       |   90|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/FailureMessage.swift:
       |    1|import Foundation
       |    2|
       |    3|/// Encapsulates the failure message that matchers can report to the end user.
       |    4|///
       |    5|/// This is shared state between Nimble and matchers that mutate this value.
       |    6|public class FailureMessage: NSObject {
       |    7|    public var expected: String = "expected"
       |    8|    public var actualValue: String? = "" // empty string -> use default; nil -> exclude
       |    9|    public var to: String = "to"
       |   10|    public var postfixMessage: String = "match"
       |   11|    public var postfixActual: String = ""
       |   12|    public var userDescription: String? = nil
       |   13|
       |   14|    public var stringValue: String {
      0|   15|        get {
      0|   16|            if let value = _stringValueOverride {
      0|   17|                return value
      0|   18|            } else {
      0|   19|                return computeStringValue()
      0|   20|            }
      0|   21|        }
      0|   22|        set {
      0|   23|            _stringValueOverride = newValue
      0|   24|        }
       |   25|    }
       |   26|
       |   27|    internal var _stringValueOverride: String?
       |   28|
     12|   29|    public override init() {
     12|   30|    }
       |   31|
      0|   32|    public init(stringValue: String) {
      0|   33|        _stringValueOverride = stringValue
      0|   34|    }
       |   35|
      0|   36|    internal func stripNewlines(str: String) -> String {
      0|   37|        var lines: [String] = NSString(string: str).componentsSeparatedByString("\n") as [String]
      0|   38|        let whitespace = NSCharacterSet.whitespaceAndNewlineCharacterSet()
      0|   39|        lines = lines.map { line in NSString(string: line).stringByTrimmingCharactersInSet(whitespace) }
      0|   40|        return lines.joinWithSeparator("")
      0|   41|    }
       |   42|
      0|   43|    internal func computeStringValue() -> String {
      0|   44|        var value = "\(expected) \(to) \(postfixMessage)"
      0|   45|        if let actualValue = actualValue {
      0|   46|            value = "\(expected) \(to) \(postfixMessage), got \(actualValue)\(postfixActual)"
      0|   47|        }
      0|   48|        value = stripNewlines(value)
      0|   49|        
      0|   50|        if let userDescription = userDescription {
      0|   51|            return "\(userDescription)\n\(value)"
      0|   52|        }
      0|   53|        
      0|   54|        return value
      0|   55|    }
       |   56|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/AllPass.swift:
       |    1|import Foundation
       |    2|
       |    3|public func allPass<T,U where U: SequenceType, U.Generator.Element == T>
      0|    4|    (passFunc: (T?) -> Bool) -> NonNilMatcherFunc<U> {
      0|    5|        return allPass("pass a condition", passFunc)
      0|    6|}
       |    7|
       |    8|public func allPass<T,U where U: SequenceType, U.Generator.Element == T>
      0|    9|    (passName: String, _ passFunc: (T?) -> Bool) -> NonNilMatcherFunc<U> {
      0|   10|        return createAllPassMatcher() {
      0|   11|            expression, failureMessage in
      0|   12|            failureMessage.postfixMessage = passName
      0|   13|            return passFunc(try expression.evaluate())
      0|   14|        }
      0|   15|}
       |   16|
       |   17|public func allPass<U,V where U: SequenceType, V: Matcher, U.Generator.Element == V.ValueType>
      0|   18|    (matcher: V) -> NonNilMatcherFunc<U> {
      0|   19|        return createAllPassMatcher() {
      0|   20|            try matcher.matches($0, failureMessage: $1)
      0|   21|        }
      0|   22|}
       |   23|
       |   24|private func createAllPassMatcher<T,U where U: SequenceType, U.Generator.Element == T>
      0|   25|    (elementEvaluator:(Expression<T>, FailureMessage) throws -> Bool) -> NonNilMatcherFunc<U> {
      0|   26|        return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   27|            failureMessage.actualValue = nil
      0|   28|            if let actualValue = try actualExpression.evaluate() {
      0|   29|                for currentElement in actualValue {
      0|   30|                    let exp = Expression(
      0|   31|                        expression: {currentElement}, location: actualExpression.location)
      0|   32|                    if try !elementEvaluator(exp, failureMessage) {
      0|   33|                        failureMessage.postfixMessage =
      0|   34|                            "all \(failureMessage.postfixMessage),"
      0|   35|                            + " but failed first at element <\(stringify(currentElement))>"
      0|   36|                            + " in <\(stringify(actualValue))>"
      0|   37|                        return false
      0|   38|                    }
      0|   39|                }
      0|   40|                failureMessage.postfixMessage = "all \(failureMessage.postfixMessage)"
      0|   41|            } else {
      0|   42|                failureMessage.postfixMessage = "all pass (use beNil() to match nils)"
      0|   43|                return false
      0|   44|            }
      0|   45|            
      0|   46|            return true
      0|   47|        }
      0|   48|}
       |   49|
       |   50|#if _runtime(_ObjC)
       |   51|extension NMBObjCMatcher {
      0|   52|    public class func allPassMatcher(matcher: NMBObjCMatcher) -> NMBObjCMatcher {
      0|   53|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   54|            let location = actualExpression.location
      0|   55|            let actualValue = try! actualExpression.evaluate()
      0|   56|            var nsObjects = [NSObject]()
      0|   57|            
      0|   58|            var collectionIsUsable = true
      0|   59|            if let value = actualValue as? NSFastEnumeration {
      0|   60|                let generator = NSFastGenerator(value)
      0|   61|                while let obj:AnyObject = generator.next() {
      0|   62|                    if let nsObject = obj as? NSObject {
      0|   63|                        nsObjects.append(nsObject)
      0|   64|                    } else {
      0|   65|                        collectionIsUsable = false
      0|   66|                        break
      0|   67|                    }
      0|   68|                }
      0|   69|            } else {
      0|   70|                collectionIsUsable = false
      0|   71|            }
      0|   72|            
      0|   73|            if !collectionIsUsable {
      0|   74|                failureMessage.postfixMessage =
      0|   75|                  "allPass only works with NSFastEnumeration (NSArray, NSSet, ...) of NSObjects"
      0|   76|                failureMessage.expected = ""
      0|   77|                failureMessage.to = ""
      0|   78|                return false
      0|   79|            }
      0|   80|            
      0|   81|            let expr = Expression(expression: ({ nsObjects }), location: location)
      0|   82|            let elementEvaluator: (Expression<NSObject>, FailureMessage) -> Bool = {
      0|   83|                expression, failureMessage in
      0|   84|                return matcher.matches(
      0|   85|                    {try! expression.evaluate()}, failureMessage: failureMessage, location: expr.location)
      0|   86|            }
      0|   87|            return try! createAllPassMatcher(elementEvaluator).matches(
      0|   88|                expr, failureMessage: failureMessage)
      0|   89|        }
      0|   90|    }
       |   91|}
       |   92|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/AsyncMatcherWrapper.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|
       |    5|public struct AsyncDefaults {
       |    6|    public static var Timeout: NSTimeInterval = 1
       |    7|    public static var PollInterval: NSTimeInterval = 0.01
       |    8|}
       |    9|
       |   10|internal struct AsyncMatcherWrapper<T, U where U: Matcher, U.ValueType == T>: Matcher {
       |   11|    let fullMatcher: U
       |   12|    let timeoutInterval: NSTimeInterval
       |   13|    let pollInterval: NSTimeInterval
       |   14|
      0|   15|    init(fullMatcher: U, timeoutInterval: NSTimeInterval = AsyncDefaults.Timeout, pollInterval: NSTimeInterval = AsyncDefaults.PollInterval) {
      0|   16|      self.fullMatcher = fullMatcher
      0|   17|      self.timeoutInterval = timeoutInterval
      0|   18|      self.pollInterval = pollInterval
      0|   19|    }
       |   20|
      0|   21|    func matches(actualExpression: Expression<T>, failureMessage: FailureMessage) -> Bool {
      0|   22|        let uncachedExpression = actualExpression.withoutCaching()
      0|   23|        let fnName = "expect(...).toEventually(...)"
      0|   24|        let result = pollBlock(
      0|   25|            pollInterval: pollInterval,
      0|   26|            timeoutInterval: timeoutInterval,
      0|   27|            file: actualExpression.location.file,
      0|   28|            line: actualExpression.location.line,
      0|   29|            fnName: fnName) {
      0|   30|                try self.fullMatcher.matches(uncachedExpression, failureMessage: failureMessage)
      0|   31|        }
      0|   32|        switch (result) {
      0|   33|        case let .Completed(isSuccessful): return isSuccessful
      0|   34|        case .TimedOut: return false
      0|   35|        case let .ErrorThrown(error):
      0|   36|            failureMessage.actualValue = "an unexpected error thrown: <\(error)>"
      0|   37|            return false
      0|   38|        case let .RaisedException(exception):
      0|   39|            failureMessage.actualValue = "an unexpected exception thrown: <\(exception)>"
      0|   40|            return false
      0|   41|        case .BlockedRunLoop:
      0|   42|            failureMessage.postfixMessage += " (timed out, but main thread was unresponsive)."
      0|   43|            return false
      0|   44|        case .Incomplete:
      0|   45|            internalError("Reached .Incomplete state for toEventually(...).")
      0|   46|        }
      0|   47|    }
       |   48|
      0|   49|    func doesNotMatch(actualExpression: Expression<T>, failureMessage: FailureMessage) -> Bool  {
      0|   50|        let uncachedExpression = actualExpression.withoutCaching()
      0|   51|        let result = pollBlock(
      0|   52|            pollInterval: pollInterval,
      0|   53|            timeoutInterval: timeoutInterval,
      0|   54|            file: actualExpression.location.file,
      0|   55|            line: actualExpression.location.line,
      0|   56|            fnName: "expect(...).toEventuallyNot(...)") {
      0|   57|                try self.fullMatcher.doesNotMatch(uncachedExpression, failureMessage: failureMessage)
      0|   58|        }
      0|   59|        switch (result) {
      0|   60|        case let .Completed(isSuccessful): return isSuccessful
      0|   61|        case .TimedOut: return false
      0|   62|        case let .ErrorThrown(error):
      0|   63|            failureMessage.actualValue = "an unexpected error thrown: <\(error)>"
      0|   64|            return false
      0|   65|        case let .RaisedException(exception):
      0|   66|            failureMessage.actualValue = "an unexpected exception thrown: <\(exception)>"
      0|   67|            return false
      0|   68|        case .BlockedRunLoop:
      0|   69|            failureMessage.postfixMessage += " (timed out, but main thread was unresponsive)."
      0|   70|            return false
      0|   71|        case .Incomplete:
      0|   72|            internalError("Reached .Incomplete state for toEventuallyNot(...).")
      0|   73|        }
      0|   74|    }
       |   75|}
       |   76|
       |   77|private let toEventuallyRequiresClosureError = FailureMessage(stringValue: "expect(...).toEventually(...) requires an explicit closure (eg - expect { ... }.toEventually(...) )\nSwift 1.2 @autoclosure behavior has changed in an incompatible way for Nimble to function")
       |   78|
       |   79|
       |   80|extension Expectation {
       |   81|    /// Tests the actual value using a matcher to match by checking continuously
       |   82|    /// at each pollInterval until the timeout is reached.
       |   83|    ///
       |   84|    /// @discussion
       |   85|    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
       |   86|    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
      0|   87|    public func toEventually<U where U: Matcher, U.ValueType == T>(matcher: U, timeout: NSTimeInterval = AsyncDefaults.Timeout, pollInterval: NSTimeInterval = AsyncDefaults.PollInterval, description: String? = nil) {
      0|   88|        if expression.isClosure {
      0|   89|            let (pass, msg) = expressionMatches(
      0|   90|                expression,
      0|   91|                matcher: AsyncMatcherWrapper(
      0|   92|                    fullMatcher: matcher,
      0|   93|                    timeoutInterval: timeout,
      0|   94|                    pollInterval: pollInterval),
      0|   95|                to: "to eventually",
      0|   96|                description: description
      0|   97|            )
      0|   98|            verify(pass, msg)
      0|   99|        } else {
      0|  100|            verify(false, toEventuallyRequiresClosureError)
      0|  101|        }
      0|  102|    }
       |  103|
       |  104|    /// Tests the actual value using a matcher to not match by checking
       |  105|    /// continuously at each pollInterval until the timeout is reached.
       |  106|    ///
       |  107|    /// @discussion
       |  108|    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
       |  109|    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
      0|  110|    public func toEventuallyNot<U where U: Matcher, U.ValueType == T>(matcher: U, timeout: NSTimeInterval = AsyncDefaults.Timeout, pollInterval: NSTimeInterval = AsyncDefaults.PollInterval, description: String? = nil) {
      0|  111|        if expression.isClosure {
      0|  112|            let (pass, msg) = expressionDoesNotMatch(
      0|  113|                expression,
      0|  114|                matcher: AsyncMatcherWrapper(
      0|  115|                    fullMatcher: matcher,
      0|  116|                    timeoutInterval: timeout,
      0|  117|                    pollInterval: pollInterval),
      0|  118|                toNot: "to eventually not",
      0|  119|                description: description
      0|  120|            )
      0|  121|            verify(pass, msg)
      0|  122|        } else {
      0|  123|            verify(false, toEventuallyRequiresClosureError)
      0|  124|        }
      0|  125|    }
       |  126|
       |  127|    /// Tests the actual value using a matcher to not match by checking
       |  128|    /// continuously at each pollInterval until the timeout is reached.
       |  129|    ///
       |  130|    /// Alias of toEventuallyNot()
       |  131|    ///
       |  132|    /// @discussion
       |  133|    /// This function manages the main run loop (`NSRunLoop.mainRunLoop()`) while this function
       |  134|    /// is executing. Any attempts to touch the run loop may cause non-deterministic behavior.
      0|  135|    public func toNotEventually<U where U: Matcher, U.ValueType == T>(matcher: U, timeout: NSTimeInterval = AsyncDefaults.Timeout, pollInterval: NSTimeInterval = AsyncDefaults.PollInterval, description: String? = nil) {
      0|  136|        return toEventuallyNot(matcher, timeout: timeout, pollInterval: pollInterval, description: description)
      0|  137|    }
       |  138|}
       |  139|
       |  140|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeAKindOf.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|
       |    5|// A Nimble matcher that catches attempts to use beAKindOf with non Objective-C types
      0|    6|public func beAKindOf(expectedClass: Any) -> NonNilMatcherFunc<Any> {
      0|    7|    return NonNilMatcherFunc {actualExpression, failureMessage in
      0|    8|        failureMessage.stringValue = "beAKindOf only works on Objective-C types since"
      0|    9|            + " the Swift compiler will automatically type check Swift-only types."
      0|   10|            + " This expectation is redundant."
      0|   11|        return false
      0|   12|    }
      0|   13|}
       |   14|
       |   15|/// A Nimble matcher that succeeds when the actual value is an instance of the given class.
       |   16|/// @see beAnInstanceOf if you want to match against the exact class
      0|   17|public func beAKindOf(expectedClass: AnyClass) -> NonNilMatcherFunc<NSObject> {
      0|   18|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   19|        let instance = try actualExpression.evaluate()
      0|   20|        if let validInstance = instance {
      0|   21|            failureMessage.actualValue = "<\(classAsString(validInstance.dynamicType)) instance>"
      0|   22|        } else {
      0|   23|            failureMessage.actualValue = "<nil>"
      0|   24|        }
      0|   25|        failureMessage.postfixMessage = "be a kind of \(classAsString(expectedClass))"
      0|   26|        return instance != nil && instance!.isKindOfClass(expectedClass)
      0|   27|    }
      0|   28|}
       |   29|
       |   30|extension NMBObjCMatcher {
      0|   31|    public class func beAKindOfMatcher(expected: AnyClass) -> NMBMatcher {
      0|   32|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   33|            return try! beAKindOf(expected).matches(actualExpression, failureMessage: failureMessage)
      0|   34|        }
      0|   35|    }
       |   36|}
       |   37|
       |   38|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeAnInstanceOf.swift:
       |    1|import Foundation
       |    2|
       |    3|// A Nimble matcher that catches attempts to use beAnInstanceOf with non Objective-C types
      0|    4|public func beAnInstanceOf(expectedClass: Any) -> NonNilMatcherFunc<Any> {
      0|    5|    return NonNilMatcherFunc {actualExpression, failureMessage in
      0|    6|        failureMessage.stringValue = "beAnInstanceOf only works on Objective-C types since"
      0|    7|            + " the Swift compiler will automatically type check Swift-only types."
      0|    8|            + " This expectation is redundant."
      0|    9|        return false
      0|   10|    }
      0|   11|}
       |   12|
       |   13|/// A Nimble matcher that succeeds when the actual value is an instance of the given class.
       |   14|/// @see beAKindOf if you want to match against subclasses
      0|   15|public func beAnInstanceOf(expectedClass: AnyClass) -> NonNilMatcherFunc<NSObject> {
      0|   16|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   17|        let instance = try actualExpression.evaluate()
      0|   18|        if let validInstance = instance {
      0|   19|            failureMessage.actualValue = "<\(classAsString(validInstance.dynamicType)) instance>"
      0|   20|        } else {
      0|   21|            failureMessage.actualValue = "<nil>"
      0|   22|        }
      0|   23|        failureMessage.postfixMessage = "be an instance of \(classAsString(expectedClass))"
      0|   24|#if _runtime(_ObjC)
      0|   25|        return instance != nil && instance!.isMemberOfClass(expectedClass)
      0|   26|#else
      0|   27|        return instance != nil && instance!.dynamicType == expectedClass
      0|   28|#endif
      0|   29|    }
      0|   30|}
       |   31|
       |   32|#if _runtime(_ObjC)
       |   33|extension NMBObjCMatcher {
      0|   34|    public class func beAnInstanceOfMatcher(expected: AnyClass) -> NMBMatcher {
      0|   35|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   36|            return try! beAnInstanceOf(expected).matches(actualExpression, failureMessage: failureMessage)
      0|   37|        }
      0|   38|    }
       |   39|}
       |   40|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeCloseTo.swift:
       |    1|#if os(Linux)
       |    2|import Glibc
       |    3|#endif
       |    4|import Foundation
       |    5|
       |    6|internal let DefaultDelta = 0.0001
       |    7|
      0|    8|internal func isCloseTo(actualValue: NMBDoubleConvertible?, expectedValue: NMBDoubleConvertible, delta: Double, failureMessage: FailureMessage) -> Bool {
      0|    9|    failureMessage.postfixMessage = "be close to <\(stringify(expectedValue))> (within \(stringify(delta)))"
      0|   10|    failureMessage.actualValue = "<\(stringify(actualValue))>"
      0|   11|    return actualValue != nil && abs(actualValue!.doubleValue - expectedValue.doubleValue) < delta
      0|   12|}
       |   13|
       |   14|/// A Nimble matcher that succeeds when a value is close to another. This is used for floating
       |   15|/// point values which can have imprecise results when doing arithmetic on them.
       |   16|///
       |   17|/// @see equal
      0|   18|public func beCloseTo(expectedValue: Double, within delta: Double = DefaultDelta) -> NonNilMatcherFunc<Double> {
      0|   19|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   20|        return isCloseTo(try actualExpression.evaluate(), expectedValue: expectedValue, delta: delta, failureMessage: failureMessage)
      0|   21|    }
      0|   22|}
       |   23|
       |   24|/// A Nimble matcher that succeeds when a value is close to another. This is used for floating
       |   25|/// point values which can have imprecise results when doing arithmetic on them.
       |   26|///
       |   27|/// @see equal
      0|   28|public func beCloseTo(expectedValue: NMBDoubleConvertible, within delta: Double = DefaultDelta) -> NonNilMatcherFunc<NMBDoubleConvertible> {
      0|   29|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   30|        return isCloseTo(try actualExpression.evaluate(), expectedValue: expectedValue, delta: delta, failureMessage: failureMessage)
      0|   31|    }
      0|   32|}
       |   33|
       |   34|#if _runtime(_ObjC)
       |   35|public class NMBObjCBeCloseToMatcher : NSObject, NMBMatcher {
       |   36|    var _expected: NSNumber
       |   37|    var _delta: CDouble
      0|   38|    init(expected: NSNumber, within: CDouble) {
      0|   39|        _expected = expected
      0|   40|        _delta = within
      0|   41|    }
       |   42|
      0|   43|    public func matches(actualExpression: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|   44|        let actualBlock: () -> NMBDoubleConvertible? = ({
      0|   45|            return actualExpression() as? NMBDoubleConvertible
      0|   46|        })
      0|   47|        let expr = Expression(expression: actualBlock, location: location)
      0|   48|        let matcher = beCloseTo(self._expected, within: self._delta)
      0|   49|        return try! matcher.matches(expr, failureMessage: failureMessage)
      0|   50|    }
       |   51|
      0|   52|    public func doesNotMatch(actualExpression: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|   53|        let actualBlock: () -> NMBDoubleConvertible? = ({
      0|   54|            return actualExpression() as? NMBDoubleConvertible
      0|   55|        })
      0|   56|        let expr = Expression(expression: actualBlock, location: location)
      0|   57|        let matcher = beCloseTo(self._expected, within: self._delta)
      0|   58|        return try! matcher.doesNotMatch(expr, failureMessage: failureMessage)
      0|   59|    }
       |   60|
      0|   61|    public var within: (CDouble) -> NMBObjCBeCloseToMatcher {
      0|   62|        return ({ delta in
      0|   63|            return NMBObjCBeCloseToMatcher(expected: self._expected, within: delta)
      0|   64|        })
      0|   65|    }
       |   66|}
       |   67|
       |   68|extension NMBObjCMatcher {
      0|   69|    public class func beCloseToMatcher(expected: NSNumber, within: CDouble) -> NMBObjCBeCloseToMatcher {
      0|   70|        return NMBObjCBeCloseToMatcher(expected: expected, within: within)
      0|   71|    }
       |   72|}
       |   73|#endif
       |   74|
      0|   75|public func beCloseTo(expectedValues: [Double], within delta: Double = DefaultDelta) -> NonNilMatcherFunc <[Double]> {
      0|   76|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   77|        failureMessage.postfixMessage = "be close to <\(stringify(expectedValues))> (each within \(stringify(delta)))"
      0|   78|        if let actual = try actualExpression.evaluate() {
      0|   79|            failureMessage.actualValue = "<\(stringify(actual))>"
      0|   80|
      0|   81|            if actual.count != expectedValues.count {
      0|   82|                return false
      0|   83|            } else {
      0|   84|                for (index, actualItem) in actual.enumerate() {
      0|   85|                    if fabs(actualItem - expectedValues[index]) > delta {
      0|   86|                        return false
      0|   87|                    }
      0|   88|                }
      0|   89|                return true
      0|   90|            }
      0|   91|        }
      0|   92|        return false
      0|   93|    }
      0|   94|}
       |   95|
       |   96|// MARK: - Operators
       |   97|
       |   98|infix operator â‰ˆ {
       |   99|    associativity none
       |  100|    precedence 130
       |  101|}
       |  102|
      0|  103|public func â‰ˆ(lhs: Expectation<[Double]>, rhs: [Double]) {
      0|  104|    lhs.to(beCloseTo(rhs))
      0|  105|}
       |  106|
      0|  107|public func â‰ˆ(lhs: Expectation<NMBDoubleConvertible>, rhs: NMBDoubleConvertible) {
      0|  108|    lhs.to(beCloseTo(rhs))
      0|  109|}
       |  110|
      0|  111|public func â‰ˆ(lhs: Expectation<NMBDoubleConvertible>, rhs: (expected: NMBDoubleConvertible, delta: Double)) {
      0|  112|    lhs.to(beCloseTo(rhs.expected, within: rhs.delta))
      0|  113|}
       |  114|
      0|  115|public func ==(lhs: Expectation<NMBDoubleConvertible>, rhs: (expected: NMBDoubleConvertible, delta: Double)) {
      0|  116|    lhs.to(beCloseTo(rhs.expected, within: rhs.delta))
      0|  117|}
       |  118|
       |  119|// make this higher precedence than exponents so the Doubles either end aren't pulled in
       |  120|// unexpectantly
       |  121|infix operator Â± { precedence 170 }
      0|  122|public func Â±(lhs: NMBDoubleConvertible, rhs: Double) -> (expected: NMBDoubleConvertible, delta: Double) {
      0|  123|    return (expected: lhs, delta: rhs)
      0|  124|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeEmpty.swift:
       |    1|import Foundation
       |    2|
       |    3|
       |    4|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |    5|/// means the are no items in that collection. For strings, it is an empty string.
      0|    6|public func beEmpty<S: SequenceType>() -> NonNilMatcherFunc<S> {
      0|    7|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    8|        failureMessage.postfixMessage = "be empty"
      0|    9|        let actualSeq = try actualExpression.evaluate()
      0|   10|        if actualSeq == nil {
      0|   11|            return true
      0|   12|        }
      0|   13|        var generator = actualSeq!.generate()
      0|   14|        return generator.next() == nil
      0|   15|    }
      0|   16|}
       |   17|
       |   18|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |   19|/// means the are no items in that collection. For strings, it is an empty string.
      0|   20|public func beEmpty() -> NonNilMatcherFunc<String> {
      0|   21|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   22|        failureMessage.postfixMessage = "be empty"
      0|   23|        let actualString = try actualExpression.evaluate()
      0|   24|        return actualString == nil || NSString(string: actualString!).length  == 0
      0|   25|    }
      0|   26|}
       |   27|
       |   28|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |   29|/// means the are no items in that collection. For NSString instances, it is an empty string.
      0|   30|public func beEmpty() -> NonNilMatcherFunc<NSString> {
      0|   31|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   32|        failureMessage.postfixMessage = "be empty"
      0|   33|        let actualString = try actualExpression.evaluate()
      0|   34|        return actualString == nil || actualString!.length == 0
      0|   35|    }
      0|   36|}
       |   37|
       |   38|// Without specific overrides, beEmpty() is ambiguous for NSDictionary, NSArray,
       |   39|// etc, since they conform to SequenceType as well as NMBCollection.
       |   40|
       |   41|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |   42|/// means the are no items in that collection. For strings, it is an empty string.
      0|   43|public func beEmpty() -> NonNilMatcherFunc<NSDictionary> {
      0|   44|	return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   45|		failureMessage.postfixMessage = "be empty"
      0|   46|		let actualDictionary = try actualExpression.evaluate()
      0|   47|		return actualDictionary == nil || actualDictionary!.count == 0
      0|   48|	}
      0|   49|}
       |   50|
       |   51|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |   52|/// means the are no items in that collection. For strings, it is an empty string.
      0|   53|public func beEmpty() -> NonNilMatcherFunc<NSArray> {
      0|   54|	return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   55|		failureMessage.postfixMessage = "be empty"
      0|   56|		let actualArray = try actualExpression.evaluate()
      0|   57|		return actualArray == nil || actualArray!.count == 0
      0|   58|	}
      0|   59|}
       |   60|
       |   61|/// A Nimble matcher that succeeds when a value is "empty". For collections, this
       |   62|/// means the are no items in that collection. For strings, it is an empty string.
      0|   63|public func beEmpty() -> NonNilMatcherFunc<NMBCollection> {
      0|   64|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   65|        failureMessage.postfixMessage = "be empty"
      0|   66|        let actual = try actualExpression.evaluate()
      0|   67|        return actual == nil || actual!.count == 0
      0|   68|    }
      0|   69|}
       |   70|
       |   71|#if _runtime(_ObjC)
       |   72|extension NMBObjCMatcher {
      0|   73|    public class func beEmptyMatcher() -> NMBObjCMatcher {
      0|   74|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   75|            let location = actualExpression.location
      0|   76|            let actualValue = try! actualExpression.evaluate()
      0|   77|            failureMessage.postfixMessage = "be empty"
      0|   78|            if let value = actualValue as? NMBCollection {
      0|   79|                let expr = Expression(expression: ({ value as NMBCollection }), location: location)
      0|   80|                return try! beEmpty().matches(expr, failureMessage: failureMessage)
      0|   81|            } else if let value = actualValue as? NSString {
      0|   82|                let expr = Expression(expression: ({ value as String }), location: location)
      0|   83|                return try! beEmpty().matches(expr, failureMessage: failureMessage)
      0|   84|            } else if let actualValue = actualValue {
      0|   85|                failureMessage.postfixMessage = "be empty (only works for NSArrays, NSSets, NSIndexSets, NSDictionaries, NSHashTables, and NSStrings)"
      0|   86|                failureMessage.actualValue = "\(classAsString(actualValue.dynamicType)) type"
      0|   87|            }
      0|   88|            return false
      0|   89|        }
      0|   90|    }
       |   91|}
       |   92|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeGreaterThan.swift:
       |    1|import Foundation
       |    2|
       |    3|
       |    4|/// A Nimble matcher that succeeds when the actual value is greater than the expected value.
      0|    5|public func beGreaterThan<T: Comparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|    6|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    7|        failureMessage.postfixMessage = "be greater than <\(stringify(expectedValue))>"
      0|    8|        return try actualExpression.evaluate() > expectedValue
      0|    9|    }
      0|   10|}
       |   11|
       |   12|/// A Nimble matcher that succeeds when the actual value is greater than the expected value.
      0|   13|public func beGreaterThan(expectedValue: NMBComparable?) -> NonNilMatcherFunc<NMBComparable> {
      0|   14|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   15|        failureMessage.postfixMessage = "be greater than <\(stringify(expectedValue))>"
      0|   16|        let actualValue = try actualExpression.evaluate()
      0|   17|        let matches = actualValue != nil && actualValue!.NMB_compare(expectedValue) == NSComparisonResult.OrderedDescending
      0|   18|        return matches
      0|   19|    }
      0|   20|}
       |   21|
      0|   22|public func ><T: Comparable>(lhs: Expectation<T>, rhs: T) {
      0|   23|    lhs.to(beGreaterThan(rhs))
      0|   24|}
       |   25|
      0|   26|public func >(lhs: Expectation<NMBComparable>, rhs: NMBComparable?) {
      0|   27|    lhs.to(beGreaterThan(rhs))
      0|   28|}
       |   29|
       |   30|#if _runtime(_ObjC)
       |   31|extension NMBObjCMatcher {
      0|   32|    public class func beGreaterThanMatcher(expected: NMBComparable?) -> NMBObjCMatcher {
      0|   33|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   34|            let expr = actualExpression.cast { $0 as? NMBComparable }
      0|   35|            return try! beGreaterThan(expected).matches(expr, failureMessage: failureMessage)
      0|   36|        }
      0|   37|    }
       |   38|}
       |   39|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeGreaterThanOrEqualTo.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is greater than
       |    4|/// or equal to the expected value.
      0|    5|public func beGreaterThanOrEqualTo<T: Comparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|    6|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    7|        failureMessage.postfixMessage = "be greater than or equal to <\(stringify(expectedValue))>"
      0|    8|        let actualValue = try actualExpression.evaluate()
      0|    9|        return actualValue >= expectedValue
      0|   10|    }
      0|   11|}
       |   12|
       |   13|/// A Nimble matcher that succeeds when the actual value is greater than
       |   14|/// or equal to the expected value.
      0|   15|public func beGreaterThanOrEqualTo<T: NMBComparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|   16|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   17|        failureMessage.postfixMessage = "be greater than or equal to <\(stringify(expectedValue))>"
      0|   18|        let actualValue = try actualExpression.evaluate()
      0|   19|        let matches = actualValue != nil && actualValue!.NMB_compare(expectedValue) != NSComparisonResult.OrderedAscending
      0|   20|        return matches
      0|   21|    }
      0|   22|}
       |   23|
      0|   24|public func >=<T: Comparable>(lhs: Expectation<T>, rhs: T) {
      0|   25|    lhs.to(beGreaterThanOrEqualTo(rhs))
      0|   26|}
       |   27|
      0|   28|public func >=<T: NMBComparable>(lhs: Expectation<T>, rhs: T) {
      0|   29|    lhs.to(beGreaterThanOrEqualTo(rhs))
      0|   30|}
       |   31|
       |   32|#if _runtime(_ObjC)
       |   33|extension NMBObjCMatcher {
      0|   34|    public class func beGreaterThanOrEqualToMatcher(expected: NMBComparable?) -> NMBObjCMatcher {
      0|   35|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   36|            let expr = actualExpression.cast { $0 as? NMBComparable }
      0|   37|            return try! beGreaterThanOrEqualTo(expected).matches(expr, failureMessage: failureMessage)
      0|   38|        }
      0|   39|    }
       |   40|}
       |   41|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeIdenticalTo.swift:
       |    1|import Foundation
       |    2|
       |    3|
       |    4|/// A Nimble matcher that succeeds when the actual value is the same instance
       |    5|/// as the expected instance.
      0|    6|public func beIdenticalTo(expected: AnyObject?) -> NonNilMatcherFunc<AnyObject> {
      0|    7|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    8|        let actual = try actualExpression.evaluate()
      0|    9|        failureMessage.actualValue = "\(identityAsString(actual))"
      0|   10|        failureMessage.postfixMessage = "be identical to \(identityAsString(expected))"
      0|   11|        return actual === expected && actual !== nil
      0|   12|    }
      0|   13|}
       |   14|
      0|   15|public func ===(lhs: Expectation<AnyObject>, rhs: AnyObject?) {
      0|   16|    lhs.to(beIdenticalTo(rhs))
      0|   17|}
      0|   18|public func !==(lhs: Expectation<AnyObject>, rhs: AnyObject?) {
      0|   19|    lhs.toNot(beIdenticalTo(rhs))
      0|   20|}
       |   21|
       |   22|/// A Nimble matcher that succeeds when the actual value is the same instance
       |   23|/// as the expected instance.
       |   24|///
       |   25|/// Alias for "beIdenticalTo".
      0|   26|public func be(expected: AnyObject?) -> NonNilMatcherFunc<AnyObject> {
      0|   27|    return beIdenticalTo(expected)
      0|   28|}
       |   29|
       |   30|#if _runtime(_ObjC)
       |   31|extension NMBObjCMatcher {
      0|   32|    public class func beIdenticalToMatcher(expected: NSObject?) -> NMBObjCMatcher {
      0|   33|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   34|            let aExpr = actualExpression.cast { $0 as AnyObject? }
      0|   35|            return try! beIdenticalTo(expected).matches(aExpr, failureMessage: failureMessage)
      0|   36|        }
      0|   37|    }
       |   38|}
       |   39|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLessThan.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is less than the expected value.
      0|    4|public func beLessThan<T: Comparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|    5|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    6|        failureMessage.postfixMessage = "be less than <\(stringify(expectedValue))>"
      0|    7|        return try actualExpression.evaluate() < expectedValue
      0|    8|    }
      0|    9|}
       |   10|
       |   11|/// A Nimble matcher that succeeds when the actual value is less than the expected value.
      0|   12|public func beLessThan(expectedValue: NMBComparable?) -> NonNilMatcherFunc<NMBComparable> {
      0|   13|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   14|        failureMessage.postfixMessage = "be less than <\(stringify(expectedValue))>"
      0|   15|        let actualValue = try actualExpression.evaluate()
      0|   16|        let matches = actualValue != nil && actualValue!.NMB_compare(expectedValue) == NSComparisonResult.OrderedAscending
      0|   17|        return matches
      0|   18|    }
      0|   19|}
       |   20|
      0|   21|public func <<T: Comparable>(lhs: Expectation<T>, rhs: T) {
      0|   22|    lhs.to(beLessThan(rhs))
      0|   23|}
       |   24|
      0|   25|public func <(lhs: Expectation<NMBComparable>, rhs: NMBComparable?) {
      0|   26|    lhs.to(beLessThan(rhs))
      0|   27|}
       |   28|
       |   29|#if _runtime(_ObjC)
       |   30|extension NMBObjCMatcher {
      0|   31|    public class func beLessThanMatcher(expected: NMBComparable?) -> NMBObjCMatcher {
      0|   32|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   33|            let expr = actualExpression.cast { $0 as! NMBComparable? }
      0|   34|            return try! beLessThan(expected).matches(expr, failureMessage: failureMessage)
      0|   35|        }
      0|   36|    }
       |   37|}
       |   38|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLessThanOrEqual.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is less than
       |    4|/// or equal to the expected value.
      0|    5|public func beLessThanOrEqualTo<T: Comparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|    6|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    7|        failureMessage.postfixMessage = "be less than or equal to <\(stringify(expectedValue))>"
      0|    8|        return try actualExpression.evaluate() <= expectedValue
      0|    9|    }
      0|   10|}
       |   11|
       |   12|/// A Nimble matcher that succeeds when the actual value is less than
       |   13|/// or equal to the expected value.
      0|   14|public func beLessThanOrEqualTo<T: NMBComparable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
      0|   15|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   16|        failureMessage.postfixMessage = "be less than or equal to <\(stringify(expectedValue))>"
      0|   17|        let actualValue = try actualExpression.evaluate()
      0|   18|        return actualValue != nil && actualValue!.NMB_compare(expectedValue) != NSComparisonResult.OrderedDescending
      0|   19|    }
      0|   20|}
       |   21|
      0|   22|public func <=<T: Comparable>(lhs: Expectation<T>, rhs: T) {
      0|   23|    lhs.to(beLessThanOrEqualTo(rhs))
      0|   24|}
       |   25|
      0|   26|public func <=<T: NMBComparable>(lhs: Expectation<T>, rhs: T) {
      0|   27|    lhs.to(beLessThanOrEqualTo(rhs))
      0|   28|}
       |   29|
       |   30|#if _runtime(_ObjC)
       |   31|extension NMBObjCMatcher {
      0|   32|    public class func beLessThanOrEqualToMatcher(expected: NMBComparable?) -> NMBObjCMatcher {
      0|   33|        return NMBObjCMatcher(canMatchNil:false) { actualExpression, failureMessage in
      0|   34|            let expr = actualExpression.cast { $0 as? NMBComparable }
      0|   35|            return try! beLessThanOrEqualTo(expected).matches(expr, failureMessage: failureMessage)
      0|   36|        }
      0|   37|    }
       |   38|}
       |   39|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeLogical.swift:
       |    1|import Foundation
       |    2|
      2|    3|internal func matcherWithFailureMessage<T>(matcher: NonNilMatcherFunc<T>, postprocessor: (FailureMessage) -> Void) -> NonNilMatcherFunc<T> {
      2|    4|    return NonNilMatcherFunc { actualExpression, failureMessage in
      2|    5|        defer { postprocessor(failureMessage) }
      2|    6|        return try matcher.matcher(actualExpression, failureMessage)
      2|    7|    }
      2|    8|}
       |    9|
       |   10|// MARK: beTrue() / beFalse()
       |   11|
       |   12|/// A Nimble matcher that succeeds when the actual value is exactly true.
       |   13|/// This matcher will not match against nils.
      1|   14|public func beTrue() -> NonNilMatcherFunc<Bool> {
      1|   15|    return matcherWithFailureMessage(equal(true)) { failureMessage in
      1|   16|        failureMessage.postfixMessage = "be true"
      1|   17|    }
      1|   18|}
       |   19|
       |   20|/// A Nimble matcher that succeeds when the actual value is exactly false.
       |   21|/// This matcher will not match against nils.
      1|   22|public func beFalse() -> NonNilMatcherFunc<Bool> {
      1|   23|    return matcherWithFailureMessage(equal(false)) { failureMessage in
      1|   24|        failureMessage.postfixMessage = "be false"
      1|   25|    }
      1|   26|}
       |   27|
       |   28|// MARK: beTruthy() / beFalsy()
       |   29|
       |   30|/// A Nimble matcher that succeeds when the actual value is not logically false.
      0|   31|public func beTruthy<T>() -> MatcherFunc<T> {
      0|   32|    return MatcherFunc { actualExpression, failureMessage in
      0|   33|        failureMessage.postfixMessage = "be truthy"
      0|   34|        let actualValue = try actualExpression.evaluate()
      0|   35|        if let actualValue = actualValue {
      0|   36|            if let actualValue = actualValue as? BooleanType {
      0|   37|                return actualValue.boolValue == true
      0|   38|            }
      0|   39|        }
      0|   40|        return actualValue != nil
      0|   41|    }
      0|   42|}
       |   43|
       |   44|/// A Nimble matcher that succeeds when the actual value is logically false.
       |   45|/// This matcher will match against nils.
      0|   46|public func beFalsy<T>() -> MatcherFunc<T> {
      0|   47|    return MatcherFunc { actualExpression, failureMessage in
      0|   48|        failureMessage.postfixMessage = "be falsy"
      0|   49|        let actualValue = try actualExpression.evaluate()
      0|   50|        if let actualValue = actualValue {
      0|   51|            if let actualValue = actualValue as? BooleanType {
      0|   52|                return actualValue.boolValue != true
      0|   53|            }
      0|   54|        }
      0|   55|        return actualValue == nil
      0|   56|    }
      0|   57|}
       |   58|
       |   59|#if _runtime(_ObjC)
       |   60|extension NMBObjCMatcher {
      0|   61|    public class func beTruthyMatcher() -> NMBObjCMatcher {
      0|   62|        return NMBObjCMatcher { actualExpression, failureMessage in
      0|   63|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false as BooleanType? }
      0|   64|            return try! beTruthy().matches(expr, failureMessage: failureMessage)
      0|   65|        }
      0|   66|    }
       |   67|
      0|   68|    public class func beFalsyMatcher() -> NMBObjCMatcher {
      0|   69|        return NMBObjCMatcher { actualExpression, failureMessage in
      0|   70|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false as BooleanType? }
      0|   71|            return try! beFalsy().matches(expr, failureMessage: failureMessage)
      0|   72|        }
      0|   73|    }
       |   74|
      0|   75|    public class func beTrueMatcher() -> NMBObjCMatcher {
      0|   76|        return NMBObjCMatcher { actualExpression, failureMessage in
      0|   77|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false as Bool? }
      0|   78|            return try! beTrue().matches(expr, failureMessage: failureMessage)
      0|   79|        }
      0|   80|    }
       |   81|
      0|   82|    public class func beFalseMatcher() -> NMBObjCMatcher {
      0|   83|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   84|            let expr = actualExpression.cast { ($0 as? NSNumber)?.boolValue ?? false as Bool? }
      0|   85|            return try! beFalse().matches(expr, failureMessage: failureMessage)
      0|   86|        }
      0|   87|    }
       |   88|}
       |   89|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeNil.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is nil.
      0|    4|public func beNil<T>() -> MatcherFunc<T> {
      0|    5|    return MatcherFunc { actualExpression, failureMessage in
      0|    6|        failureMessage.postfixMessage = "be nil"
      0|    7|        let actualValue = try actualExpression.evaluate()
      0|    8|        return actualValue == nil
      0|    9|    }
      0|   10|}
       |   11|
       |   12|#if _runtime(_ObjC)
       |   13|extension NMBObjCMatcher {
      0|   14|    public class func beNilMatcher() -> NMBObjCMatcher {
      0|   15|        return NMBObjCMatcher { actualExpression, failureMessage in
      0|   16|            return try! beNil().matches(actualExpression, failureMessage: failureMessage)
      0|   17|        }
      0|   18|    }
       |   19|}
       |   20|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeVoid.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is Void.
      0|    4|public func beVoid() -> MatcherFunc<()> {
      0|    5|    return MatcherFunc { actualExpression, failureMessage in
      0|    6|        failureMessage.postfixMessage = "be void"
      0|    7|        let actualValue: ()? = try actualExpression.evaluate()
      0|    8|        return actualValue != nil
      0|    9|    }
      0|   10|}
       |   11|
      0|   12|public func ==(lhs: Expectation<()>, rhs: ()) {
      0|   13|    lhs.to(beVoid())
      0|   14|}
       |   15|
      0|   16|public func !=(lhs: Expectation<()>, rhs: ()) {
      0|   17|    lhs.toNot(beVoid())
      0|   18|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/BeginWith.swift:
       |    1|import Foundation
       |    2|
       |    3|
       |    4|/// A Nimble matcher that succeeds when the actual sequence's first element
       |    5|/// is equal to the expected value.
      0|    6|public func beginWith<S: SequenceType, T: Equatable where S.Generator.Element == T>(startingElement: T) -> NonNilMatcherFunc<S> {
      0|    7|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    8|        failureMessage.postfixMessage = "begin with <\(startingElement)>"
      0|    9|        if let actualValue = try actualExpression.evaluate() {
      0|   10|            var actualGenerator = actualValue.generate()
      0|   11|            return actualGenerator.next() == startingElement
      0|   12|        }
      0|   13|        return false
      0|   14|    }
      0|   15|}
       |   16|
       |   17|/// A Nimble matcher that succeeds when the actual collection's first element
       |   18|/// is equal to the expected object.
      0|   19|public func beginWith(startingElement: AnyObject) -> NonNilMatcherFunc<NMBOrderedCollection> {
      0|   20|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   21|        failureMessage.postfixMessage = "begin with <\(startingElement)>"
      0|   22|        let collection = try actualExpression.evaluate()
      0|   23|        return collection != nil && collection!.indexOfObject(startingElement) == 0
      0|   24|    }
      0|   25|}
       |   26|
       |   27|/// A Nimble matcher that succeeds when the actual string contains expected substring
       |   28|/// where the expected substring's location is zero.
      0|   29|public func beginWith(startingSubstring: String) -> NonNilMatcherFunc<String> {
      0|   30|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   31|        failureMessage.postfixMessage = "begin with <\(startingSubstring)>"
      0|   32|        if let actual = try actualExpression.evaluate() {
      0|   33|            let range = actual.rangeOfString(startingSubstring)
      0|   34|            return range != nil && range!.startIndex == actual.startIndex
      0|   35|        }
      0|   36|        return false
      0|   37|    }
      0|   38|}
       |   39|
       |   40|#if _runtime(_ObjC)
       |   41|extension NMBObjCMatcher {
      0|   42|    public class func beginWithMatcher(expected: AnyObject) -> NMBObjCMatcher {
      0|   43|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   44|            let actual = try! actualExpression.evaluate()
      0|   45|            if let _ = actual as? String {
      0|   46|                let expr = actualExpression.cast { $0 as? String }
      0|   47|                return try! beginWith(expected as! String).matches(expr, failureMessage: failureMessage)
      0|   48|            } else {
      0|   49|                let expr = actualExpression.cast { $0 as? NMBOrderedCollection }
      0|   50|                return try! beginWith(expected).matches(expr, failureMessage: failureMessage)
      0|   51|            }
      0|   52|        }
      0|   53|    }
       |   54|}
       |   55|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/Contain.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual sequence contains the expected value.
      0|    4|public func contain<S: SequenceType, T: Equatable where S.Generator.Element == T>(items: T...) -> NonNilMatcherFunc<S> {
      0|    5|    return contain(items)
      0|    6|}
       |    7|
      0|    8|public func contain<S: SequenceType, T: Equatable where S.Generator.Element == T>(items: [T]) -> NonNilMatcherFunc<S> {
      0|    9|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   10|        failureMessage.postfixMessage = "contain <\(arrayAsString(items))>"
      0|   11|        if let actual = try actualExpression.evaluate() {
      0|   12|            return items.all {
      0|   13|                return actual.contains($0)
      0|   14|            }
      0|   15|        }
      0|   16|        return false
      0|   17|    }
      0|   18|}
       |   19|
       |   20|/// A Nimble matcher that succeeds when the actual string contains the expected substring.
      0|   21|public func contain(substrings: String...) -> NonNilMatcherFunc<String> {
      0|   22|    return contain(substrings)
      0|   23|}
       |   24|
      0|   25|public func contain(substrings: [String]) -> NonNilMatcherFunc<String> {
      0|   26|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   27|        failureMessage.postfixMessage = "contain <\(arrayAsString(substrings))>"
      0|   28|        if let actual = try actualExpression.evaluate() {
      0|   29|            return substrings.all {
      0|   30|                let range = actual.rangeOfString($0)
      0|   31|                return range != nil && !range!.isEmpty
      0|   32|            }
      0|   33|        }
      0|   34|        return false
      0|   35|    }
      0|   36|}
       |   37|
       |   38|/// A Nimble matcher that succeeds when the actual string contains the expected substring.
      0|   39|public func contain(substrings: NSString...) -> NonNilMatcherFunc<NSString> {
      0|   40|    return contain(substrings)
      0|   41|}
       |   42|
      0|   43|public func contain(substrings: [NSString]) -> NonNilMatcherFunc<NSString> {
      0|   44|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   45|        failureMessage.postfixMessage = "contain <\(arrayAsString(substrings))>"
      0|   46|        if let actual = try actualExpression.evaluate() {
      0|   47|            return substrings.all { actual.rangeOfString($0.description).length != 0 }
      0|   48|        }
      0|   49|        return false
      0|   50|    }
      0|   51|}
       |   52|
       |   53|/// A Nimble matcher that succeeds when the actual collection contains the expected object.
      0|   54|public func contain(items: AnyObject?...) -> NonNilMatcherFunc<NMBContainer> {
      0|   55|    return contain(items)
      0|   56|}
       |   57|
      0|   58|public func contain(items: [AnyObject?]) -> NonNilMatcherFunc<NMBContainer> {
      0|   59|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   60|        failureMessage.postfixMessage = "contain <\(arrayAsString(items))>"
      0|   61|        guard let actual = try actualExpression.evaluate() else { return false }
      0|   62|        return items.all { item in
      0|   63|            return item != nil && actual.containsObject(item!)
      0|   64|        }
      0|   65|    }
      0|   66|}
       |   67|
       |   68|#if _runtime(_ObjC)
       |   69|extension NMBObjCMatcher {
      0|   70|    public class func containMatcher(expected: [NSObject]) -> NMBObjCMatcher {
      0|   71|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   72|            let location = actualExpression.location
      0|   73|            let actualValue = try! actualExpression.evaluate()
      0|   74|            if let value = actualValue as? NMBContainer {
      0|   75|                let expr = Expression(expression: ({ value as NMBContainer }), location: location)
      0|   76|
      0|   77|                // A straightforward cast on the array causes this to crash, so we have to cast the individual items
      0|   78|                let expectedOptionals: [AnyObject?] = expected.map({ $0 as AnyObject? })
      0|   79|                return try! contain(expectedOptionals).matches(expr, failureMessage: failureMessage)
      0|   80|            } else if let value = actualValue as? NSString {
      0|   81|                let expr = Expression(expression: ({ value as String }), location: location)
      0|   82|                return try! contain(expected as! [String]).matches(expr, failureMessage: failureMessage)
      0|   83|            } else if actualValue != nil {
      0|   84|                failureMessage.postfixMessage = "contain <\(arrayAsString(expected))> (only works for NSArrays, NSSets, NSHashTables, and NSStrings)"
      0|   85|            } else {
      0|   86|                failureMessage.postfixMessage = "contain <\(arrayAsString(expected))>"
      0|   87|            }
      0|   88|            return false
      0|   89|        }
      0|   90|    }
       |   91|}
       |   92|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/EndWith.swift:
       |    1|import Foundation
       |    2|
       |    3|
       |    4|/// A Nimble matcher that succeeds when the actual sequence's last element
       |    5|/// is equal to the expected value.
      0|    6|public func endWith<S: SequenceType, T: Equatable where S.Generator.Element == T>(endingElement: T) -> NonNilMatcherFunc<S> {
      0|    7|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    8|        failureMessage.postfixMessage = "end with <\(endingElement)>"
      0|    9|
      0|   10|        if let actualValue = try actualExpression.evaluate() {
      0|   11|            var actualGenerator = actualValue.generate()
      0|   12|            var lastItem: T?
      0|   13|            var item: T?
      0|   14|            repeat {
      0|   15|                lastItem = item
      0|   16|                item = actualGenerator.next()
      0|   17|            } while(item != nil)
      0|   18|            
      0|   19|            return lastItem == endingElement
      0|   20|        }
      0|   21|        return false
      0|   22|    }
      0|   23|}
       |   24|
       |   25|/// A Nimble matcher that succeeds when the actual collection's last element
       |   26|/// is equal to the expected object.
      0|   27|public func endWith(endingElement: AnyObject) -> NonNilMatcherFunc<NMBOrderedCollection> {
      0|   28|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   29|        failureMessage.postfixMessage = "end with <\(endingElement)>"
      0|   30|        let collection = try actualExpression.evaluate()
      0|   31|        return collection != nil && collection!.indexOfObject(endingElement) == collection!.count - 1
      0|   32|    }
      0|   33|}
       |   34|
       |   35|
       |   36|/// A Nimble matcher that succeeds when the actual string contains the expected substring
       |   37|/// where the expected substring's location is the actual string's length minus the
       |   38|/// expected substring's length.
      0|   39|public func endWith(endingSubstring: String) -> NonNilMatcherFunc<String> {
      0|   40|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   41|        failureMessage.postfixMessage = "end with <\(endingSubstring)>"
      0|   42|        if let collection = try actualExpression.evaluate() {
      0|   43|            let range = collection.rangeOfString(endingSubstring)
      0|   44|            return range != nil && range!.endIndex == collection.endIndex
      0|   45|        }
      0|   46|        return false
      0|   47|    }
      0|   48|}
       |   49|
       |   50|#if _runtime(_ObjC)
       |   51|extension NMBObjCMatcher {
      0|   52|    public class func endWithMatcher(expected: AnyObject) -> NMBObjCMatcher {
      0|   53|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   54|            let actual = try! actualExpression.evaluate()
      0|   55|            if let _ = actual as? String {
      0|   56|                let expr = actualExpression.cast { $0 as? String }
      0|   57|                return try! endWith(expected as! String).matches(expr, failureMessage: failureMessage)
      0|   58|            } else {
      0|   59|                let expr = actualExpression.cast { $0 as? NMBOrderedCollection }
      0|   60|                return try! endWith(expected).matches(expr, failureMessage: failureMessage)
      0|   61|            }
      0|   62|        }
      0|   63|    }
       |   64|}
       |   65|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/Equal.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value is equal to the expected value.
       |    4|/// Values can support equal by supporting the Equatable protocol.
       |    5|///
       |    6|/// @see beCloseTo if you want to match imprecise types (eg - floats, doubles).
     12|    7|public func equal<T: Equatable>(expectedValue: T?) -> NonNilMatcherFunc<T> {
     12|    8|    return NonNilMatcherFunc { actualExpression, failureMessage in
     12|    9|        failureMessage.postfixMessage = "equal <\(stringify(expectedValue))>"
     12|   10|        let actualValue = try actualExpression.evaluate()
     12|   11|        let matches = actualValue == expectedValue && expectedValue != nil
     12|   12|        if expectedValue == nil || actualValue == nil {
      0|   13|            if expectedValue == nil {
      0|   14|                failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   15|            }
      0|   16|            return false
     12|   17|        }
     12|   18|        return matches
     12|   19|    }
     12|   20|}
       |   21|
       |   22|/// A Nimble matcher that succeeds when the actual value is equal to the expected value.
       |   23|/// Values can support equal by supporting the Equatable protocol.
       |   24|///
       |   25|/// @see beCloseTo if you want to match imprecise types (eg - floats, doubles).
      0|   26|public func equal<T: Equatable, C: Equatable>(expectedValue: [T: C]?) -> NonNilMatcherFunc<[T: C]> {
      0|   27|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   28|        failureMessage.postfixMessage = "equal <\(stringify(expectedValue))>"
      0|   29|        let actualValue = try actualExpression.evaluate()
      0|   30|        if expectedValue == nil || actualValue == nil {
      0|   31|            if expectedValue == nil {
      0|   32|                failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   33|            }
      0|   34|            return false
      0|   35|        }
      0|   36|        return expectedValue! == actualValue!
      0|   37|    }
      0|   38|}
       |   39|
       |   40|/// A Nimble matcher that succeeds when the actual collection is equal to the expected collection.
       |   41|/// Items must implement the Equatable protocol.
      0|   42|public func equal<T: Equatable>(expectedValue: [T]?) -> NonNilMatcherFunc<[T]> {
      0|   43|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   44|        failureMessage.postfixMessage = "equal <\(stringify(expectedValue))>"
      0|   45|        let actualValue = try actualExpression.evaluate()
      0|   46|        if expectedValue == nil || actualValue == nil {
      0|   47|            if expectedValue == nil {
      0|   48|                failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   49|            }
      0|   50|            return false
      0|   51|        }
      0|   52|        return expectedValue! == actualValue!
      0|   53|    }
      0|   54|}
       |   55|
       |   56|/// A Nimble matcher allowing comparison of collection with optional type
      0|   57|public func equal<T: Equatable>(expectedValue: [T?]) -> NonNilMatcherFunc<[T?]> {
      0|   58|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   59|        failureMessage.postfixMessage = "equal <\(stringify(expectedValue))>"
      0|   60|        if let actualValue = try actualExpression.evaluate() {
      0|   61|            if expectedValue.count != actualValue.count {
      0|   62|                return false
      0|   63|            }
      0|   64|            
      0|   65|            for (index, item) in actualValue.enumerate() {
      0|   66|                let otherItem = expectedValue[index]
      0|   67|                if item == nil && otherItem == nil {
      0|   68|                    continue
      0|   69|                } else if item == nil && otherItem != nil {
      0|   70|                    return false
      0|   71|                } else if item != nil && otherItem == nil {
      0|   72|                    return false
      0|   73|                } else if item! != otherItem! {
      0|   74|                    return false
      0|   75|                }
      0|   76|            }
      0|   77|            
      0|   78|            return true
      0|   79|        } else {
      0|   80|            failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   81|        }
      0|   82|        
      0|   83|        return false
      0|   84|    }
      0|   85|}
       |   86|
       |   87|/// A Nimble matcher that succeeds when the actual set is equal to the expected set.
      0|   88|public func equal<T>(expectedValue: Set<T>?) -> NonNilMatcherFunc<Set<T>> {
      0|   89|    return equal(expectedValue, stringify: stringify)
      0|   90|}
       |   91|
       |   92|/// A Nimble matcher that succeeds when the actual set is equal to the expected set.
      0|   93|public func equal<T: Comparable>(expectedValue: Set<T>?) -> NonNilMatcherFunc<Set<T>> {
      0|   94|    return equal(expectedValue, stringify: {
      0|   95|        if let set = $0 {
      0|   96|            return stringify(Array(set).sort { $0 < $1 })
      0|   97|        } else {
      0|   98|            return "nil"
      0|   99|        }
      0|  100|    })
      0|  101|}
       |  102|
      0|  103|private func equal<T>(expectedValue: Set<T>?, stringify: Set<T>? -> String) -> NonNilMatcherFunc<Set<T>> {
      0|  104|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|  105|        failureMessage.postfixMessage = "equal <\(stringify(expectedValue))>"
      0|  106|
      0|  107|        if let expectedValue = expectedValue {
      0|  108|            if let actualValue = try actualExpression.evaluate() {
      0|  109|                failureMessage.actualValue = "<\(stringify(actualValue))>"
      0|  110|
      0|  111|                if expectedValue == actualValue {
      0|  112|                    return true
      0|  113|                }
      0|  114|
      0|  115|                let missing = expectedValue.subtract(actualValue)
      0|  116|                if missing.count > 0 {
      0|  117|                    failureMessage.postfixActual += ", missing <\(stringify(missing))>"
      0|  118|                }
      0|  119|
      0|  120|                let extra = actualValue.subtract(expectedValue)
      0|  121|                if extra.count > 0 {
      0|  122|                    failureMessage.postfixActual += ", extra <\(stringify(extra))>"
      0|  123|                }
      0|  124|            }
      0|  125|        } else {
      0|  126|            failureMessage.postfixActual = " (use beNil() to match nils)"
      0|  127|        }
      0|  128|
      0|  129|        return false
      0|  130|    }
      0|  131|}
       |  132|
      0|  133|public func ==<T: Equatable>(lhs: Expectation<T>, rhs: T?) {
      0|  134|    lhs.to(equal(rhs))
      0|  135|}
       |  136|
      0|  137|public func !=<T: Equatable>(lhs: Expectation<T>, rhs: T?) {
      0|  138|    lhs.toNot(equal(rhs))
      0|  139|}
       |  140|
      0|  141|public func ==<T: Equatable>(lhs: Expectation<[T]>, rhs: [T]?) {
      0|  142|    lhs.to(equal(rhs))
      0|  143|}
       |  144|
      0|  145|public func !=<T: Equatable>(lhs: Expectation<[T]>, rhs: [T]?) {
      0|  146|    lhs.toNot(equal(rhs))
      0|  147|}
       |  148|
      0|  149|public func ==<T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
      0|  150|    lhs.to(equal(rhs))
      0|  151|}
       |  152|
      0|  153|public func !=<T>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
      0|  154|    lhs.toNot(equal(rhs))
      0|  155|}
       |  156|
      0|  157|public func ==<T: Comparable>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
      0|  158|    lhs.to(equal(rhs))
      0|  159|}
       |  160|
      0|  161|public func !=<T: Comparable>(lhs: Expectation<Set<T>>, rhs: Set<T>?) {
      0|  162|    lhs.toNot(equal(rhs))
      0|  163|}
       |  164|
      0|  165|public func ==<T: Equatable, C: Equatable>(lhs: Expectation<[T: C]>, rhs: [T: C]?) {
      0|  166|    lhs.to(equal(rhs))
      0|  167|}
       |  168|
      0|  169|public func !=<T: Equatable, C: Equatable>(lhs: Expectation<[T: C]>, rhs: [T: C]?) {
      0|  170|    lhs.toNot(equal(rhs))
      0|  171|}
       |  172|
       |  173|#if _runtime(_ObjC)
       |  174|extension NMBObjCMatcher {
      0|  175|    public class func equalMatcher(expected: NSObject) -> NMBMatcher {
      0|  176|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|  177|            return try! equal(expected).matches(actualExpression, failureMessage: failureMessage)
      0|  178|        }
      0|  179|    }
       |  180|}
       |  181|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/HaveCount.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual CollectionType's count equals
       |    4|/// the expected value
      0|    5|public func haveCount<T: CollectionType>(expectedValue: T.Index.Distance) -> NonNilMatcherFunc<T> {
      0|    6|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    7|        if let actualValue = try actualExpression.evaluate() {
      0|    8|            failureMessage.postfixMessage = "have \(stringify(actualValue)) with count \(stringify(expectedValue))"
      0|    9|            let result = expectedValue == actualValue.count
      0|   10|            failureMessage.actualValue = "\(actualValue.count)"
      0|   11|            return result
      0|   12|        } else {
      0|   13|            return false
      0|   14|        }
      0|   15|    }
      0|   16|}
       |   17|
       |   18|/// A Nimble matcher that succeeds when the actual collection's count equals
       |   19|/// the expected value
      0|   20|public func haveCount(expectedValue: Int) -> MatcherFunc<NMBCollection> {
      0|   21|    return MatcherFunc { actualExpression, failureMessage in
      0|   22|        if let actualValue = try actualExpression.evaluate() {
      0|   23|            failureMessage.postfixMessage = "have \(stringify(actualValue)) with count \(stringify(expectedValue))"
      0|   24|            let result = expectedValue == actualValue.count
      0|   25|            failureMessage.actualValue = "\(actualValue.count)"
      0|   26|            return result
      0|   27|        } else {
      0|   28|            return false
      0|   29|        }
      0|   30|    }
      0|   31|}
       |   32|
       |   33|#if _runtime(_ObjC)
       |   34|extension NMBObjCMatcher {
      0|   35|    public class func haveCountMatcher(expected: NSNumber) -> NMBObjCMatcher {
      0|   36|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   37|            let location = actualExpression.location
      0|   38|            let actualValue = try! actualExpression.evaluate()
      0|   39|            if let value = actualValue as? NMBCollection {
      0|   40|                let expr = Expression(expression: ({ value as NMBCollection}), location: location)
      0|   41|                return try! haveCount(expected.integerValue).matches(expr, failureMessage: failureMessage)
      0|   42|            } else if let actualValue = actualValue {
      0|   43|                failureMessage.postfixMessage = "get type of NSArray, NSSet, NSDictionary, or NSHashTable"
      0|   44|                failureMessage.actualValue = "\(classAsString(actualValue.dynamicType))"
      0|   45|            }
      0|   46|            return false
      0|   47|        }
      0|   48|    }
       |   49|}
       |   50|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/Match.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|
       |    5|/// A Nimble matcher that succeeds when the actual string satisfies the regular expression
       |    6|/// described by the expected string.
      0|    7|public func match(expectedValue: String?) -> NonNilMatcherFunc<String> {
      0|    8|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|    9|        failureMessage.postfixMessage = "match <\(stringify(expectedValue))>"
      0|   10|        
      0|   11|        if let actual = try actualExpression.evaluate() {
      0|   12|            if let regexp = expectedValue {
      0|   13|                return actual.rangeOfString(regexp, options: .RegularExpressionSearch) != nil
      0|   14|            }
      0|   15|        }
      0|   16|
      0|   17|        return false
      0|   18|    }
      0|   19|}
       |   20|
       |   21|extension NMBObjCMatcher {
      0|   22|    public class func matchMatcher(expected: NSString) -> NMBMatcher {
      0|   23|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   24|            let actual = actualExpression.cast { $0 as? String }
      0|   25|            return try! match(expected.description).matches(actual, failureMessage: failureMessage)
      0|   26|        }
      0|   27|    }
       |   28|}
       |   29|
       |   30|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/MatchError.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual expression evaluates to an
       |    4|/// error from the specified case.
       |    5|///
       |    6|/// Errors are tried to be compared by their implementation of Equatable,
       |    7|/// otherwise they fallback to comparision by _domain and _code.
      0|    8|public func matchError<T: ErrorType>(error: T) -> NonNilMatcherFunc<ErrorType> {
      0|    9|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   10|        let actualError: ErrorType? = try actualExpression.evaluate()
      0|   11|
      0|   12|        setFailureMessageForError(failureMessage, postfixMessageVerb: "match", actualError: actualError, error: error)
      0|   13|        return errorMatchesNonNilFieldsOrClosure(actualError, error: error)
      0|   14|    }
      0|   15|}
       |   16|
       |   17|/// A Nimble matcher that succeeds when the actual expression evaluates to an
       |   18|/// error of the specified type
      0|   19|public func matchError<T: ErrorType>(errorType: T.Type) -> NonNilMatcherFunc<ErrorType> {
      0|   20|    return NonNilMatcherFunc { actualExpression, failureMessage in
      0|   21|        let actualError: ErrorType? = try actualExpression.evaluate()
      0|   22|
      0|   23|        setFailureMessageForError(failureMessage, postfixMessageVerb: "match", actualError: actualError, errorType: errorType)
      0|   24|        return errorMatchesNonNilFieldsOrClosure(actualError, errorType: errorType)
      0|   25|    }
      0|   26|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherFunc.swift:
       |    1|/// A convenience API to build matchers that don't need special negation
       |    2|/// behavior. The toNot() behavior is the negation of to().
       |    3|///
       |    4|/// @see NonNilMatcherFunc if you prefer to have this matcher fail when nil
       |    5|///                        values are recieved in an expectation.
       |    6|///
       |    7|/// You may use this when implementing your own custom matchers.
       |    8|///
       |    9|/// Use the Matcher protocol instead of this type to accept custom matchers as
       |   10|/// input parameters.
       |   11|/// @see allPass for an example that uses accepts other matchers as input.
       |   12|public struct MatcherFunc<T>: Matcher {
       |   13|    public let matcher: (Expression<T>, FailureMessage) throws -> Bool
       |   14|
      0|   15|    public init(_ matcher: (Expression<T>, FailureMessage) throws -> Bool) {
      0|   16|        self.matcher = matcher
      0|   17|    }
       |   18|
      0|   19|    public func matches(actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
      0|   20|        return try matcher(actualExpression, failureMessage)
      0|   21|    }
       |   22|
      0|   23|    public func doesNotMatch(actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
      0|   24|        return try !matcher(actualExpression, failureMessage)
      0|   25|    }
       |   26|}
       |   27|
       |   28|/// A convenience API to build matchers that don't need special negation
       |   29|/// behavior. The toNot() behavior is the negation of to().
       |   30|///
       |   31|/// Unlike MatcherFunc, this will always fail if an expectation contains nil.
       |   32|/// This applies regardless of using to() or toNot().
       |   33|///
       |   34|/// You may use this when implementing your own custom matchers.
       |   35|///
       |   36|/// Use the Matcher protocol instead of this type to accept custom matchers as
       |   37|/// input parameters.
       |   38|/// @see allPass for an example that uses accepts other matchers as input.
       |   39|public struct NonNilMatcherFunc<T>: Matcher {
       |   40|    public let matcher: (Expression<T>, FailureMessage) throws -> Bool
       |   41|
     14|   42|    public init(_ matcher: (Expression<T>, FailureMessage) throws -> Bool) {
     14|   43|        self.matcher = matcher
     14|   44|    }
       |   45|
     12|   46|    public func matches(actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
     12|   47|        let pass = try matcher(actualExpression, failureMessage)
      0|   48|        if try attachNilErrorIfNeeded(actualExpression, failureMessage: failureMessage) {
      0|   49|            return false
     12|   50|        }
     12|   51|        return pass
     12|   52|    }
       |   53|
      0|   54|    public func doesNotMatch(actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
      0|   55|        let pass = try !matcher(actualExpression, failureMessage)
      0|   56|        if try attachNilErrorIfNeeded(actualExpression, failureMessage: failureMessage) {
      0|   57|            return false
      0|   58|        }
      0|   59|        return pass
      0|   60|    }
       |   61|
     12|   62|    internal func attachNilErrorIfNeeded(actualExpression: Expression<T>, failureMessage: FailureMessage) throws -> Bool {
      0|   63|        if try actualExpression.evaluate() == nil {
      0|   64|            failureMessage.postfixActual = " (use beNil() to match nils)"
      0|   65|            return true
     12|   66|        }
     12|   67|        return false
     12|   68|    }
       |   69|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/MatcherProtocols.swift:
       |    1|import Foundation
       |    2|
       |    3|/// Implement this protocol to implement a custom matcher for Swift
       |    4|public protocol Matcher {
       |    5|    associatedtype ValueType
       |    6|    func matches(actualExpression: Expression<ValueType>, failureMessage: FailureMessage) throws -> Bool
       |    7|    func doesNotMatch(actualExpression: Expression<ValueType>, failureMessage: FailureMessage) throws -> Bool
       |    8|}
       |    9|
       |   10|#if _runtime(_ObjC)
       |   11|/// Objective-C interface to the Swift variant of Matcher.
       |   12|@objc public protocol NMBMatcher {
       |   13|    func matches(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool
       |   14|    func doesNotMatch(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool
       |   15|}
       |   16|#endif
       |   17|
       |   18|#if _runtime(_ObjC)
       |   19|/// Protocol for types that support contain() matcher.
       |   20|@objc public protocol NMBContainer {
       |   21|    func containsObject(object: AnyObject!) -> Bool
       |   22|}
       |   23|
       |   24|extension NSHashTable : NMBContainer {} // Corelibs Foundation does not include this class yet
       |   25|#else
       |   26|public protocol NMBContainer {
       |   27|    func containsObject(object: AnyObject) -> Bool
       |   28|}
       |   29|#endif
       |   30|
       |   31|extension NSArray : NMBContainer {}
       |   32|extension NSSet : NMBContainer {}
       |   33|
       |   34|#if _runtime(_ObjC)
       |   35|/// Protocol for types that support only beEmpty(), haveCount() matchers
       |   36|@objc public protocol NMBCollection {
       |   37|    var count: Int { get }
       |   38|}
       |   39|
       |   40|extension NSHashTable : NMBCollection {} // Corelibs Foundation does not include these classes yet
       |   41|extension NSMapTable : NMBCollection {}
       |   42|#else
       |   43|public protocol NMBCollection {
       |   44|    var count: Int { get }
       |   45|}
       |   46|#endif
       |   47|
       |   48|extension NSSet : NMBCollection {}
       |   49|extension NSIndexSet : NMBCollection {}
       |   50|extension NSDictionary : NMBCollection {}
       |   51|
       |   52|#if _runtime(_ObjC)
       |   53|/// Protocol for types that support beginWith(), endWith(), beEmpty() matchers
       |   54|@objc public protocol NMBOrderedCollection : NMBCollection {
       |   55|    func indexOfObject(object: AnyObject!) -> Int
       |   56|}
       |   57|#else
       |   58|public protocol NMBOrderedCollection : NMBCollection {
       |   59|    func indexOfObject(object: AnyObject) -> Int
       |   60|}
       |   61|#endif
       |   62|
       |   63|extension NSArray : NMBOrderedCollection {}
       |   64|
       |   65|#if _runtime(_ObjC)
       |   66|/// Protocol for types to support beCloseTo() matcher
       |   67|@objc public protocol NMBDoubleConvertible {
       |   68|    var doubleValue: CDouble { get }
       |   69|}
       |   70|#else
       |   71|public protocol NMBDoubleConvertible {
       |   72|    var doubleValue: CDouble { get }
       |   73|}
       |   74|
       |   75|extension Double : NMBDoubleConvertible {
       |   76|    public var doubleValue: CDouble {
       |   77|        get {
       |   78|            return self
       |   79|        }
       |   80|    }
       |   81|}
       |   82|
       |   83|extension Float : NMBDoubleConvertible {
       |   84|    public var doubleValue: CDouble {
       |   85|        get {
       |   86|            return CDouble(self)
       |   87|        }
       |   88|    }
       |   89|}
       |   90|#endif
       |   91|
       |   92|extension NSNumber : NMBDoubleConvertible {
       |   93|}
       |   94|
       |   95|private let dateFormatter: NSDateFormatter = {
       |   96|    let formatter = NSDateFormatter()
       |   97|    formatter.dateFormat = "yyyy-MM-dd HH:mm:ss.SSSS"
       |   98|    formatter.locale = NSLocale(localeIdentifier: "en_US_POSIX")
       |   99|
       |  100|    return formatter
       |  101|}()
       |  102|
       |  103|#if _runtime(_ObjC)
       |  104|extension NSDate: NMBDoubleConvertible {
       |  105|    public var doubleValue: CDouble {
      0|  106|        get {
      0|  107|            return self.timeIntervalSinceReferenceDate
      0|  108|        }
       |  109|    }
       |  110|}
       |  111|#endif
       |  112|
       |  113|extension NSDate: TestOutputStringConvertible {
      0|  114|    public var testDescription: String {
      0|  115|        return dateFormatter.stringFromDate(self)
      0|  116|    }
       |  117|}
       |  118|
       |  119|/// Protocol for types to support beLessThan(), beLessThanOrEqualTo(),
       |  120|///  beGreaterThan(), beGreaterThanOrEqualTo(), and equal() matchers.
       |  121|///
       |  122|/// Types that conform to Swift's Comparable protocol will work implicitly too
       |  123|#if _runtime(_ObjC)
       |  124|@objc public protocol NMBComparable {
       |  125|    func NMB_compare(otherObject: NMBComparable!) -> NSComparisonResult
       |  126|}
       |  127|#else
       |  128|// This should become obsolete once Corelibs Foundation adds Comparable conformance to NSNumber
       |  129|public protocol NMBComparable {
       |  130|    func NMB_compare(otherObject: NMBComparable!) -> NSComparisonResult
       |  131|}
       |  132|#endif
       |  133|
       |  134|extension NSNumber : NMBComparable {
      0|  135|    public func NMB_compare(otherObject: NMBComparable!) -> NSComparisonResult {
      0|  136|        return compare(otherObject as! NSNumber)
      0|  137|    }
       |  138|}
       |  139|extension NSString : NMBComparable {
      0|  140|    public func NMB_compare(otherObject: NMBComparable!) -> NSComparisonResult {
      0|  141|        return compare(otherObject as! String)
      0|  142|    }
       |  143|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/PostNotification.swift:
       |    1|import Foundation
       |    2|
       |    3|internal class NotificationCollector {
       |    4|    private(set) var observedNotifications: [NSNotification]
       |    5|    private let notificationCenter: NSNotificationCenter
       |    6|    #if _runtime(_ObjC)
       |    7|    private var token: AnyObject?
       |    8|    #else
       |    9|    private var token: NSObjectProtocol?
       |   10|    #endif
       |   11|
      0|   12|    required init(notificationCenter: NSNotificationCenter) {
      0|   13|        self.notificationCenter = notificationCenter
      0|   14|        self.observedNotifications = []
      0|   15|    }
       |   16|
      0|   17|    func startObserving() {
      0|   18|        self.token = self.notificationCenter.addObserverForName(nil, object: nil, queue: nil) {
      0|   19|            // linux-swift gets confused by .append(n)
      0|   20|            [weak self] n in self?.observedNotifications += [n]
      0|   21|        }
      0|   22|    }
       |   23|
      0|   24|    deinit {
      0|   25|        #if _runtime(_ObjC)
      0|   26|            if let token = self.token {
      0|   27|                self.notificationCenter.removeObserver(token)
      0|   28|            }
      0|   29|        #else
      0|   30|            if let token = self.token as? AnyObject {
      0|   31|                self.notificationCenter.removeObserver(token)
      0|   32|            }
      0|   33|        #endif
      0|   34|    }
       |   35|}
       |   36|
       |   37|private let mainThread = pthread_self()
       |   38|
       |   39|public func postNotifications<T where T: Matcher, T.ValueType == [NSNotification]>(
       |   40|    notificationsMatcher: T,
       |   41|    fromNotificationCenter center: NSNotificationCenter = NSNotificationCenter.defaultCenter())
      0|   42|    -> MatcherFunc<Any> {
      0|   43|        let _ = mainThread // Force lazy-loading of this value
      0|   44|        let collector = NotificationCollector(notificationCenter: center)
      0|   45|        collector.startObserving()
      0|   46|        var once: Bool = false
      0|   47|        return MatcherFunc { actualExpression, failureMessage in
      0|   48|            let collectorNotificationsExpression = Expression(memoizedExpression: { _ in
      0|   49|                return collector.observedNotifications
      0|   50|                }, location: actualExpression.location, withoutCaching: true)
      0|   51|
      0|   52|            assert(pthread_equal(mainThread, pthread_self()) != 0, "Only expecting closure to be evaluated on main thread.")
      0|   53|            if !once {
      0|   54|                once = true
      0|   55|                try actualExpression.evaluate()
      0|   56|            }
      0|   57|
      0|   58|            let match = try notificationsMatcher.matches(collectorNotificationsExpression, failureMessage: failureMessage)
      0|   59|            if collector.observedNotifications.isEmpty {
      0|   60|                failureMessage.actualValue = "no notifications"
      0|   61|            } else {
      0|   62|                failureMessage.actualValue = "<\(stringify(collector.observedNotifications))>"
      0|   63|            }
      0|   64|            return match
      0|   65|        }
      0|   66|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/RaisesException.swift:
       |    1|import Foundation
       |    2|
       |    3|// This matcher requires the Objective-C, and being built by Xcode rather than the Swift Package Manager 
       |    4|#if _runtime(_ObjC) && !SWIFT_PACKAGE
       |    5|
       |    6|/// A Nimble matcher that succeeds when the actual expression raises an
       |    7|/// exception with the specified name, reason, and/or userInfo.
       |    8|///
       |    9|/// Alternatively, you can pass a closure to do any arbitrary custom matching
       |   10|/// to the raised exception. The closure only gets called when an exception
       |   11|/// is raised.
       |   12|///
       |   13|/// nil arguments indicates that the matcher should not attempt to match against
       |   14|/// that parameter.
       |   15|public func raiseException(
       |   16|    named named: String? = nil,
       |   17|    reason: String? = nil,
       |   18|    userInfo: NSDictionary? = nil,
      0|   19|    closure: ((NSException) -> Void)? = nil) -> MatcherFunc<Any> {
      0|   20|        return MatcherFunc { actualExpression, failureMessage in
      0|   21|
      0|   22|            var exception: NSException?
      0|   23|            let capture = NMBExceptionCapture(handler: ({ e in
      0|   24|                exception = e
      0|   25|            }), finally: nil)
      0|   26|
      0|   27|            capture.tryBlock {
      0|   28|                try! actualExpression.evaluate()
      0|   29|                return
      0|   30|            }
      0|   31|
      0|   32|            setFailureMessageForException(failureMessage, exception: exception, named: named, reason: reason, userInfo: userInfo, closure: closure)
      0|   33|            return exceptionMatchesNonNilFieldsOrClosure(exception, named: named, reason: reason, userInfo: userInfo, closure: closure)
      0|   34|        }
      0|   35|}
       |   36|
       |   37|internal func setFailureMessageForException(
       |   38|    failureMessage: FailureMessage,
       |   39|    exception: NSException?,
       |   40|    named: String?,
       |   41|    reason: String?,
       |   42|    userInfo: NSDictionary?,
      0|   43|    closure: ((NSException) -> Void)?) {
      0|   44|        failureMessage.postfixMessage = "raise exception"
      0|   45|
      0|   46|        if let named = named {
      0|   47|            failureMessage.postfixMessage += " with name <\(named)>"
      0|   48|        }
      0|   49|        if let reason = reason {
      0|   50|            failureMessage.postfixMessage += " with reason <\(reason)>"
      0|   51|        }
      0|   52|        if let userInfo = userInfo {
      0|   53|            failureMessage.postfixMessage += " with userInfo <\(userInfo)>"
      0|   54|        }
      0|   55|        if let _ = closure {
      0|   56|            failureMessage.postfixMessage += " that satisfies block"
      0|   57|        }
      0|   58|        if named == nil && reason == nil && userInfo == nil && closure == nil {
      0|   59|            failureMessage.postfixMessage = "raise any exception"
      0|   60|        }
      0|   61|
      0|   62|        if let exception = exception {
      0|   63|            failureMessage.actualValue = "\(classAsString(exception.dynamicType)) { name=\(exception.name), reason='\(stringify(exception.reason))', userInfo=\(stringify(exception.userInfo)) }"
      0|   64|        } else {
      0|   65|            failureMessage.actualValue = "no exception"
      0|   66|        }
      0|   67|}
       |   68|
       |   69|internal func exceptionMatchesNonNilFieldsOrClosure(
       |   70|    exception: NSException?,
       |   71|    named: String?,
       |   72|    reason: String?,
       |   73|    userInfo: NSDictionary?,
      0|   74|    closure: ((NSException) -> Void)?) -> Bool {
      0|   75|        var matches = false
      0|   76|
      0|   77|        if let exception = exception {
      0|   78|            matches = true
      0|   79|
      0|   80|            if named != nil && exception.name != named {
      0|   81|                matches = false
      0|   82|            }
      0|   83|            if reason != nil && exception.reason != reason {
      0|   84|                matches = false
      0|   85|            }
      0|   86|            if userInfo != nil && exception.userInfo != userInfo {
      0|   87|                matches = false
      0|   88|            }
      0|   89|            if let closure = closure {
      0|   90|                let assertions = gatherFailingExpectations {
      0|   91|                    closure(exception)
      0|   92|                }
      0|   93|                let messages = assertions.map { $0.message }
      0|   94|                if messages.count > 0 {
      0|   95|                    matches = false
      0|   96|                }
      0|   97|            }
      0|   98|        }
      0|   99|        
      0|  100|        return matches
      0|  101|}
       |  102|
       |  103|public class NMBObjCRaiseExceptionMatcher : NSObject, NMBMatcher {
       |  104|    internal var _name: String?
       |  105|    internal var _reason: String?
       |  106|    internal var _userInfo: NSDictionary?
       |  107|    internal var _block: ((NSException) -> Void)?
       |  108|
      0|  109|    internal init(name: String?, reason: String?, userInfo: NSDictionary?, block: ((NSException) -> Void)?) {
      0|  110|        _name = name
      0|  111|        _reason = reason
      0|  112|        _userInfo = userInfo
      0|  113|        _block = block
      0|  114|    }
       |  115|
      0|  116|    public func matches(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|  117|        let block: () -> Any? = ({ actualBlock(); return nil })
      0|  118|        let expr = Expression(expression: block, location: location)
      0|  119|
      0|  120|        return try! raiseException(
      0|  121|            named: _name,
      0|  122|            reason: _reason,
      0|  123|            userInfo: _userInfo,
      0|  124|            closure: _block
      0|  125|        ).matches(expr, failureMessage: failureMessage)
      0|  126|    }
       |  127|
      0|  128|    public func doesNotMatch(actualBlock: () -> NSObject!, failureMessage: FailureMessage, location: SourceLocation) -> Bool {
      0|  129|        return !matches(actualBlock, failureMessage: failureMessage, location: location)
      0|  130|    }
       |  131|
      0|  132|    public var named: (name: String) -> NMBObjCRaiseExceptionMatcher {
      0|  133|        return ({ name in
      0|  134|            return NMBObjCRaiseExceptionMatcher(
      0|  135|                name: name,
      0|  136|                reason: self._reason,
      0|  137|                userInfo: self._userInfo,
      0|  138|                block: self._block
      0|  139|            )
      0|  140|        })
      0|  141|    }
       |  142|
      0|  143|    public var reason: (reason: String?) -> NMBObjCRaiseExceptionMatcher {
      0|  144|        return ({ reason in
      0|  145|            return NMBObjCRaiseExceptionMatcher(
      0|  146|                name: self._name,
      0|  147|                reason: reason,
      0|  148|                userInfo: self._userInfo,
      0|  149|                block: self._block
      0|  150|            )
      0|  151|        })
      0|  152|    }
       |  153|
      0|  154|    public var userInfo: (userInfo: NSDictionary?) -> NMBObjCRaiseExceptionMatcher {
      0|  155|        return ({ userInfo in
      0|  156|            return NMBObjCRaiseExceptionMatcher(
      0|  157|                name: self._name,
      0|  158|                reason: self._reason,
      0|  159|                userInfo: userInfo,
      0|  160|                block: self._block
      0|  161|            )
      0|  162|        })
      0|  163|    }
       |  164|
      0|  165|    public var satisfyingBlock: (block: ((NSException) -> Void)?) -> NMBObjCRaiseExceptionMatcher {
      0|  166|        return ({ block in
      0|  167|            return NMBObjCRaiseExceptionMatcher(
      0|  168|                name: self._name,
      0|  169|                reason: self._reason,
      0|  170|                userInfo: self._userInfo,
      0|  171|                block: block
      0|  172|            )
      0|  173|        })
      0|  174|    }
       |  175|}
       |  176|
       |  177|extension NMBObjCMatcher {
      0|  178|    public class func raiseExceptionMatcher() -> NMBObjCRaiseExceptionMatcher {
      0|  179|        return NMBObjCRaiseExceptionMatcher(name: nil, reason: nil, userInfo: nil, block: nil)
      0|  180|    }
       |  181|}
       |  182|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/SatisfyAnyOf.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual value matches with any of the matchers
       |    4|/// provided in the variable list of matchers. 
      0|    5|public func satisfyAnyOf<T,U where U: Matcher, U.ValueType == T>(matchers: U...) -> NonNilMatcherFunc<T> {
      0|    6|    return satisfyAnyOf(matchers)
      0|    7|}
       |    8|
      0|    9|internal func satisfyAnyOf<T,U where U: Matcher, U.ValueType == T>(matchers: [U]) -> NonNilMatcherFunc<T> {
      0|   10|    return NonNilMatcherFunc<T> { actualExpression, failureMessage in
      0|   11|        let postfixMessages = NSMutableArray()
      0|   12|        var matches = false
      0|   13|        for matcher in matchers {
      0|   14|            if try matcher.matches(actualExpression, failureMessage: failureMessage) {
      0|   15|                matches = true
      0|   16|            }
      0|   17|            postfixMessages.addObject(NSString(string: "{\(failureMessage.postfixMessage)}"))
      0|   18|        }
      0|   19|
      0|   20|        failureMessage.postfixMessage = "match one of: " + postfixMessages.componentsJoinedByString(", or ")
      0|   21|        if let actualValue = try actualExpression.evaluate() {
      0|   22|            failureMessage.actualValue = "\(actualValue)"
      0|   23|        }
      0|   24|
      0|   25|        return matches
      0|   26|    }
      0|   27|}
       |   28|
      0|   29|public func ||<T>(left: NonNilMatcherFunc<T>, right: NonNilMatcherFunc<T>) -> NonNilMatcherFunc<T> {
      0|   30|    return satisfyAnyOf(left, right)
      0|   31|}
       |   32|
      0|   33|public func ||<T>(left: MatcherFunc<T>, right: MatcherFunc<T>) -> NonNilMatcherFunc<T> {
      0|   34|    return satisfyAnyOf(left, right)
      0|   35|}
       |   36|
       |   37|#if _runtime(_ObjC)
       |   38|extension NMBObjCMatcher {
      0|   39|    public class func satisfyAnyOfMatcher(matchers: [NMBObjCMatcher]) -> NMBObjCMatcher {
      0|   40|        return NMBObjCMatcher(canMatchNil: false) { actualExpression, failureMessage in
      0|   41|            if matchers.isEmpty {
      0|   42|                failureMessage.stringValue = "satisfyAnyOf must be called with at least one matcher"
      0|   43|                return false
      0|   44|            }
      0|   45|            
      0|   46|            var elementEvaluators = [NonNilMatcherFunc<NSObject>]()
      0|   47|            for matcher in matchers {
      0|   48|                let elementEvaluator: (Expression<NSObject>, FailureMessage) -> Bool = {
      0|   49|                    expression, failureMessage in
      0|   50|                    return matcher.matches(
      0|   51|                        {try! expression.evaluate()}, failureMessage: failureMessage, location: actualExpression.location)
      0|   52|                }
      0|   53|                
      0|   54|                elementEvaluators.append(NonNilMatcherFunc(elementEvaluator))
      0|   55|            }
      0|   56|            
      0|   57|            return try! satisfyAnyOf(elementEvaluators).matches(actualExpression, failureMessage: failureMessage)
      0|   58|        }
      0|   59|    }
       |   60|}
       |   61|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Matchers/ThrowError.swift:
       |    1|import Foundation
       |    2|
       |    3|/// A Nimble matcher that succeeds when the actual expression throws an
       |    4|/// error of the specified type or from the specified case.
       |    5|///
       |    6|/// Errors are tried to be compared by their implementation of Equatable,
       |    7|/// otherwise they fallback to comparision by _domain and _code.
       |    8|///
       |    9|/// Alternatively, you can pass a closure to do any arbitrary custom matching
       |   10|/// to the thrown error. The closure only gets called when an error was thrown.
       |   11|///
       |   12|/// nil arguments indicates that the matcher should not attempt to match against
       |   13|/// that parameter.
       |   14|public func throwError<T: ErrorType>(
       |   15|    error: T? = nil,
       |   16|    errorType: T.Type? = nil,
      0|   17|    closure: ((T) -> Void)? = nil) -> MatcherFunc<Any> {
      0|   18|        return MatcherFunc { actualExpression, failureMessage in
      0|   19|
      0|   20|            var actualError: ErrorType?
      0|   21|            do {
      0|   22|                try actualExpression.evaluate()
      0|   23|            } catch let catchedError {
      0|   24|                actualError = catchedError
      0|   25|            }
      0|   26|
      0|   27|            setFailureMessageForError(failureMessage, actualError: actualError, error: error, errorType: errorType, closure: closure)
      0|   28|            return errorMatchesNonNilFieldsOrClosure(actualError, error: error, errorType: errorType, closure: closure)
      0|   29|        }
      0|   30|}
       |   31|
       |   32|/// A Nimble matcher that succeeds when the actual expression throws any
       |   33|/// error or when the passed closures' arbitrary custom matching succeeds.
       |   34|///
       |   35|/// This duplication to it's generic adequate is required to allow to receive
       |   36|/// values of the existential type ErrorType in the closure.
       |   37|///
       |   38|/// The closure only gets called when an error was thrown.
       |   39|public func throwError(
      0|   40|    closure closure: ((ErrorType) -> Void)? = nil) -> MatcherFunc<Any> {
      0|   41|        return MatcherFunc { actualExpression, failureMessage in
      0|   42|            
      0|   43|            var actualError: ErrorType?
      0|   44|            do {
      0|   45|                try actualExpression.evaluate()
      0|   46|            } catch let catchedError {
      0|   47|                actualError = catchedError
      0|   48|            }
      0|   49|            
      0|   50|            setFailureMessageForError(failureMessage, actualError: actualError, closure: closure)
      0|   51|            return errorMatchesNonNilFieldsOrClosure(actualError, closure: closure)
      0|   52|        }
      0|   53|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Utils/Async.swift:
       |    1|import Foundation
       |    2|
       |    3|#if _runtime(_ObjC)
       |    4|import Dispatch
       |    5|
       |    6|private let timeoutLeeway: UInt64 = NSEC_PER_MSEC
       |    7|private let pollLeeway: UInt64 = NSEC_PER_MSEC
       |    8|
       |    9|/// Stores debugging information about callers
       |   10|internal struct WaitingInfo: CustomStringConvertible {
       |   11|    let name: String
       |   12|    let file: FileString
       |   13|    let lineNumber: UInt
       |   14|
      0|   15|    var description: String {
      0|   16|        return "\(name) at \(file):\(lineNumber)"
      0|   17|    }
       |   18|}
       |   19|
       |   20|internal protocol WaitLock {
       |   21|    func acquireWaitingLock(fnName: String, file: FileString, line: UInt)
       |   22|    func releaseWaitingLock()
       |   23|    func isWaitingLocked() -> Bool
       |   24|}
       |   25|
       |   26|internal class AssertionWaitLock: WaitLock {
       |   27|    private var currentWaiter: WaitingInfo? = nil
      1|   28|    init() { }
       |   29|
      0|   30|    func acquireWaitingLock(fnName: String, file: FileString, line: UInt) {
      0|   31|        let info = WaitingInfo(name: fnName, file: file, lineNumber: line)
      0|   32|        nimblePrecondition(
      0|   33|            NSThread.isMainThread(),
      0|   34|            "InvalidNimbleAPIUsage",
      0|   35|            "\(fnName) can only run on the main thread."
      0|   36|        )
      0|   37|        nimblePrecondition(
      0|   38|            currentWaiter == nil,
      0|   39|            "InvalidNimbleAPIUsage",
      0|   40|            "Nested async expectations are not allowed to avoid creating flaky tests.\n\n" +
      0|   41|            "The call to\n\t\(info)\n" +
      0|   42|            "triggered this exception because\n\t\(currentWaiter!)\n" +
      0|   43|            "is currently managing the main run loop."
      0|   44|        )
      0|   45|        currentWaiter = info
      0|   46|    }
       |   47|
      0|   48|    func isWaitingLocked() -> Bool {
      0|   49|        return currentWaiter != nil
      0|   50|    }
       |   51|
      0|   52|    func releaseWaitingLock() {
      0|   53|        currentWaiter = nil
      0|   54|    }
       |   55|}
       |   56|
       |   57|internal enum AwaitResult<T> {
       |   58|    /// Incomplete indicates None (aka - this value hasn't been fulfilled yet)
       |   59|    case Incomplete
       |   60|    /// TimedOut indicates the result reached its defined timeout limit before returning
       |   61|    case TimedOut
       |   62|    /// BlockedRunLoop indicates the main runloop is too busy processing other blocks to trigger
       |   63|    /// the timeout code.
       |   64|    ///
       |   65|    /// This may also mean the async code waiting upon may have never actually ran within the
       |   66|    /// required time because other timers & sources are running on the main run loop.
       |   67|    case BlockedRunLoop
       |   68|    /// The async block successfully executed and returned a given result
       |   69|    case Completed(T)
       |   70|    /// When a Swift Error is thrown
       |   71|    case ErrorThrown(ErrorType)
       |   72|    /// When an Objective-C Exception is raised
       |   73|    case RaisedException(NSException)
       |   74|
      0|   75|    func isIncomplete() -> Bool {
      0|   76|        switch self {
      0|   77|        case .Incomplete: return true
      0|   78|        default: return false
      0|   79|        }
      0|   80|    }
       |   81|
      0|   82|    func isCompleted() -> Bool {
      0|   83|        switch self {
      0|   84|        case .Completed(_): return true
      0|   85|        default: return false
      0|   86|        }
      0|   87|    }
       |   88|}
       |   89|
       |   90|/// Holds the resulting value from an asynchronous expectation.
       |   91|/// This class is thread-safe at receiving an "response" to this promise.
       |   92|internal class AwaitPromise<T> {
       |   93|    private(set) internal var asyncResult: AwaitResult<T> = .Incomplete
       |   94|    private var signal: dispatch_semaphore_t
       |   95|
      0|   96|    init() {
      0|   97|        signal = dispatch_semaphore_create(1)
      0|   98|    }
       |   99|
       |  100|    /// Resolves the promise with the given result if it has not been resolved. Repeated calls to
       |  101|    /// this method will resolve in a no-op.
       |  102|    ///
       |  103|    /// @returns a Bool that indicates if the async result was accepted or rejected because another
       |  104|    ///          value was recieved first.
      0|  105|    func resolveResult(result: AwaitResult<T>) -> Bool {
      0|  106|        if dispatch_semaphore_wait(signal, DISPATCH_TIME_NOW) == 0 {
      0|  107|            self.asyncResult = result
      0|  108|            return true
      0|  109|        } else {
      0|  110|            return false
      0|  111|        }
      0|  112|    }
       |  113|}
       |  114|
       |  115|internal struct AwaitTrigger {
       |  116|    let timeoutSource: dispatch_source_t
       |  117|    let actionSource: dispatch_source_t?
       |  118|    let start: () throws -> Void
       |  119|}
       |  120|
       |  121|/// Factory for building fully configured AwaitPromises and waiting for their results.
       |  122|///
       |  123|/// This factory stores all the state for an async expectation so that Await doesn't
       |  124|/// doesn't have to manage it.
       |  125|internal class AwaitPromiseBuilder<T> {
       |  126|    let awaiter: Awaiter
       |  127|    let waitLock: WaitLock
       |  128|    let trigger: AwaitTrigger
       |  129|    let promise: AwaitPromise<T>
       |  130|
       |  131|    internal init(
       |  132|        awaiter: Awaiter,
       |  133|        waitLock: WaitLock,
       |  134|        promise: AwaitPromise<T>,
      0|  135|        trigger: AwaitTrigger) {
      0|  136|            self.awaiter = awaiter
      0|  137|            self.waitLock = waitLock
      0|  138|            self.promise = promise
      0|  139|            self.trigger = trigger
      0|  140|    }
       |  141|
      0|  142|    func timeout(timeoutInterval: NSTimeInterval, forcefullyAbortTimeout: NSTimeInterval) -> Self {
      0|  143|        // = Discussion =
      0|  144|        //
      0|  145|        // There's a lot of technical decisions here that is useful to elaborate on. This is
      0|  146|        // definitely more lower-level than the previous NSRunLoop based implementation.
      0|  147|        //
      0|  148|        //
      0|  149|        // Why Dispatch Source?
      0|  150|        //
      0|  151|        //
      0|  152|        // We're using a dispatch source to have better control of the run loop behavior.
      0|  153|        // A timer source gives us deferred-timing control without having to rely as much on
      0|  154|        // a run loop's traditional dispatching machinery (eg - NSTimers, DefaultRunLoopMode, etc.)
      0|  155|        // which is ripe for getting corrupted by application code.
      0|  156|        //
      0|  157|        // And unlike dispatch_async(), we can control how likely our code gets prioritized to
      0|  158|        // executed (see leeway parameter) + DISPATCH_TIMER_STRICT.
      0|  159|        //
      0|  160|        // This timer is assumed to run on the HIGH priority queue to ensure it maintains the
      0|  161|        // highest priority over normal application / test code when possible.
      0|  162|        //
      0|  163|        //
      0|  164|        // Run Loop Management
      0|  165|        //
      0|  166|        // In order to properly interrupt the waiting behavior performed by this factory class,
      0|  167|        // this timer stops the main run loop to tell the waiter code that the result should be
      0|  168|        // checked.
      0|  169|        //
      0|  170|        // In addition, stopping the run loop is used to halt code executed on the main run loop.
      0|  171|        dispatch_source_set_timer(
      0|  172|            trigger.timeoutSource,
      0|  173|            dispatch_time(DISPATCH_TIME_NOW, Int64(timeoutInterval * Double(NSEC_PER_SEC))),
      0|  174|            DISPATCH_TIME_FOREVER,
      0|  175|            timeoutLeeway
      0|  176|        )
      0|  177|        dispatch_source_set_event_handler(trigger.timeoutSource) {
      0|  178|            guard self.promise.asyncResult.isIncomplete() else { return }
      0|  179|            let timedOutSem = dispatch_semaphore_create(0)
      0|  180|            let semTimedOutOrBlocked = dispatch_semaphore_create(0)
      0|  181|            dispatch_semaphore_signal(semTimedOutOrBlocked)
      0|  182|            let runLoop = CFRunLoopGetMain()
      0|  183|            CFRunLoopPerformBlock(runLoop, kCFRunLoopDefaultMode) {
      0|  184|                if dispatch_semaphore_wait(semTimedOutOrBlocked, DISPATCH_TIME_NOW) == 0 {
      0|  185|                    dispatch_semaphore_signal(timedOutSem)
      0|  186|                    dispatch_semaphore_signal(semTimedOutOrBlocked)
      0|  187|                    if self.promise.resolveResult(.TimedOut) {
      0|  188|                        CFRunLoopStop(CFRunLoopGetMain())
      0|  189|                    }
      0|  190|                }
      0|  191|            }
      0|  192|            // potentially interrupt blocking code on run loop to let timeout code run
      0|  193|            CFRunLoopStop(runLoop)
      0|  194|            let now = dispatch_time(DISPATCH_TIME_NOW, Int64(forcefullyAbortTimeout * Double(NSEC_PER_SEC)))
      0|  195|            let didNotTimeOut = dispatch_semaphore_wait(timedOutSem, now) != 0
      0|  196|            let timeoutWasNotTriggered = dispatch_semaphore_wait(semTimedOutOrBlocked, 0) == 0
      0|  197|            if didNotTimeOut && timeoutWasNotTriggered {
      0|  198|                if self.promise.resolveResult(.BlockedRunLoop) {
      0|  199|                    CFRunLoopStop(CFRunLoopGetMain())
      0|  200|                }
      0|  201|            }
      0|  202|        }
      0|  203|        return self
      0|  204|    }
       |  205|
       |  206|    /// Blocks for an asynchronous result.
       |  207|    ///
       |  208|    /// @discussion
       |  209|    /// This function must be executed on the main thread and cannot be nested. This is because
       |  210|    /// this function (and it's related methods) coordinate through the main run loop. Tampering
       |  211|    /// with the run loop can cause undesireable behavior.
       |  212|    ///
       |  213|    /// This method will return an AwaitResult in the following cases:
       |  214|    ///
       |  215|    /// - The main run loop is blocked by other operations and the async expectation cannot be
       |  216|    ///   be stopped.
       |  217|    /// - The async expectation timed out
       |  218|    /// - The async expectation succeeded
       |  219|    /// - The async expectation raised an unexpected exception (objc)
       |  220|    /// - The async expectation raised an unexpected error (swift)
       |  221|    ///
       |  222|    /// The returned AwaitResult will NEVER be .Incomplete.
      0|  223|    func wait(fnName: String = #function, file: FileString = #file, line: UInt = #line) -> AwaitResult<T> {
      0|  224|        waitLock.acquireWaitingLock(
      0|  225|            fnName,
      0|  226|            file: file,
      0|  227|            line: line)
      0|  228|
      0|  229|        let capture = NMBExceptionCapture(handler: ({ exception in
      0|  230|            self.promise.resolveResult(.RaisedException(exception))
      0|  231|        }), finally: ({
      0|  232|            self.waitLock.releaseWaitingLock()
      0|  233|        }))
      0|  234|        capture.tryBlock {
      0|  235|            do {
      0|  236|                try self.trigger.start()
      0|  237|            } catch let error {
      0|  238|                self.promise.resolveResult(.ErrorThrown(error))
      0|  239|            }
      0|  240|            dispatch_resume(self.trigger.timeoutSource)
      0|  241|            while self.promise.asyncResult.isIncomplete() {
      0|  242|                // Stopping the run loop does not work unless we run only 1 mode
      0|  243|                NSRunLoop.currentRunLoop().runMode(NSDefaultRunLoopMode, beforeDate: NSDate.distantFuture())
      0|  244|            }
      0|  245|            dispatch_suspend(self.trigger.timeoutSource)
      0|  246|            dispatch_source_cancel(self.trigger.timeoutSource)
      0|  247|            if let asyncSource = self.trigger.actionSource {
      0|  248|                dispatch_source_cancel(asyncSource)
      0|  249|            }
      0|  250|        }
      0|  251|
      0|  252|        return promise.asyncResult
      0|  253|    }
       |  254|}
       |  255|
       |  256|internal class Awaiter {
       |  257|    let waitLock: WaitLock
       |  258|    let timeoutQueue: dispatch_queue_t
       |  259|    let asyncQueue: dispatch_queue_t
       |  260|
       |  261|    internal init(
       |  262|        waitLock: WaitLock,
       |  263|        asyncQueue: dispatch_queue_t,
      1|  264|        timeoutQueue: dispatch_queue_t) {
      1|  265|            self.waitLock = waitLock
      1|  266|            self.asyncQueue = asyncQueue
      1|  267|            self.timeoutQueue = timeoutQueue
      1|  268|    }
       |  269|
      0|  270|    private func createTimerSource(queue: dispatch_queue_t) -> dispatch_source_t {
      0|  271|        return dispatch_source_create(
      0|  272|            DISPATCH_SOURCE_TYPE_TIMER,
      0|  273|            0,
      0|  274|            DISPATCH_TIMER_STRICT,
      0|  275|            queue
      0|  276|        )
      0|  277|    }
       |  278|
       |  279|    func performBlock<T>(
      0|  280|        closure: ((T) -> Void) throws -> Void) -> AwaitPromiseBuilder<T> {
      0|  281|            let promise = AwaitPromise<T>()
      0|  282|            let timeoutSource = createTimerSource(timeoutQueue)
      0|  283|            var completionCount = 0
      0|  284|            let trigger = AwaitTrigger(timeoutSource: timeoutSource, actionSource: nil) {
      0|  285|                try closure() {
      0|  286|                    completionCount += 1
      0|  287|                    nimblePrecondition(
      0|  288|                        completionCount < 2,
      0|  289|                        "InvalidNimbleAPIUsage",
      0|  290|                        "Done closure's was called multiple times. waitUntil(..) expects its " +
      0|  291|                        "completion closure to only be called once.")
      0|  292|                    if promise.resolveResult(.Completed($0)) {
      0|  293|                        CFRunLoopStop(CFRunLoopGetMain())
      0|  294|                    }
      0|  295|                }
      0|  296|            }
      0|  297|
      0|  298|            return AwaitPromiseBuilder(
      0|  299|                awaiter: self,
      0|  300|                waitLock: waitLock,
      0|  301|                promise: promise,
      0|  302|                trigger: trigger)
      0|  303|    }
       |  304|
      0|  305|    func poll<T>(pollInterval: NSTimeInterval, closure: () throws -> T?) -> AwaitPromiseBuilder<T> {
      0|  306|        let promise = AwaitPromise<T>()
      0|  307|        let timeoutSource = createTimerSource(timeoutQueue)
      0|  308|        let asyncSource = createTimerSource(asyncQueue)
      0|  309|        let trigger = AwaitTrigger(timeoutSource: timeoutSource, actionSource: asyncSource) {
      0|  310|            let interval = UInt64(pollInterval * Double(NSEC_PER_SEC))
      0|  311|            dispatch_source_set_timer(asyncSource, DISPATCH_TIME_NOW, interval, pollLeeway)
      0|  312|            dispatch_source_set_event_handler(asyncSource) {
      0|  313|                do {
      0|  314|                    if let result = try closure() {
      0|  315|                        if promise.resolveResult(.Completed(result)) {
      0|  316|                            CFRunLoopStop(CFRunLoopGetCurrent())
      0|  317|                        }
      0|  318|                    }
      0|  319|                } catch let error {
      0|  320|                    if promise.resolveResult(.ErrorThrown(error)) {
      0|  321|                        CFRunLoopStop(CFRunLoopGetCurrent())
      0|  322|                    }
      0|  323|                }
      0|  324|            }
      0|  325|            dispatch_resume(asyncSource)
      0|  326|        }
      0|  327|
      0|  328|        return AwaitPromiseBuilder(
      0|  329|            awaiter: self,
      0|  330|            waitLock: waitLock,
      0|  331|            promise: promise,
      0|  332|            trigger: trigger)
      0|  333|    }
       |  334|}
       |  335|
       |  336|internal func pollBlock(
       |  337|    pollInterval pollInterval: NSTimeInterval,
       |  338|    timeoutInterval: NSTimeInterval,
       |  339|    file: FileString,
       |  340|    line: UInt,
       |  341|    fnName: String = #function,
      0|  342|    expression: () throws -> Bool) -> AwaitResult<Bool> {
      0|  343|        let awaiter = NimbleEnvironment.activeInstance.awaiter
      0|  344|        let result = awaiter.poll(pollInterval) { () throws -> Bool? in
      0|  345|            do {
      0|  346|                if try expression() {
      0|  347|                    return true
      0|  348|                }
      0|  349|                return nil
      0|  350|            } catch let error {
      0|  351|                throw error
      0|  352|            }
      0|  353|        }.timeout(timeoutInterval, forcefullyAbortTimeout: timeoutInterval / 2.0).wait(fnName, file: file, line: line)
      0|  354|
      0|  355|        return result
      0|  356|}
       |  357|
       |  358|#endif

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Utils/Errors.swift:
       |    1|import Foundation
       |    2|
       |    3|// Generic
       |    4|
       |    5|internal func setFailureMessageForError<T: ErrorType>(
       |    6|    failureMessage: FailureMessage,
       |    7|    postfixMessageVerb: String = "throw",
       |    8|    actualError: ErrorType?,
       |    9|    error: T? = nil,
       |   10|    errorType: T.Type? = nil,
      0|   11|    closure: ((T) -> Void)? = nil) {
      0|   12|    failureMessage.postfixMessage = "\(postfixMessageVerb) error"
      0|   13|
      0|   14|    if let error = error {
      0|   15|        if let error = error as? CustomDebugStringConvertible {
      0|   16|            failureMessage.postfixMessage += " <\(error.debugDescription)>"
      0|   17|        } else {
      0|   18|            failureMessage.postfixMessage += " <\(error)>"
      0|   19|        }
      0|   20|    } else if errorType != nil || closure != nil {
      0|   21|        failureMessage.postfixMessage += " from type <\(T.self)>"
      0|   22|    }
      0|   23|    if let _ = closure {
      0|   24|        failureMessage.postfixMessage += " that satisfies block"
      0|   25|    }
      0|   26|    if error == nil && errorType == nil && closure == nil {
      0|   27|        failureMessage.postfixMessage = "\(postfixMessageVerb) any error"
      0|   28|    }
      0|   29|
      0|   30|    if let actualError = actualError {
      0|   31|        failureMessage.actualValue = "<\(actualError)>"
      0|   32|    } else {
      0|   33|        failureMessage.actualValue = "no error"
      0|   34|    }
      0|   35|}
       |   36|
       |   37|internal func errorMatchesExpectedError<T: ErrorType>(
       |   38|    actualError: ErrorType,
      0|   39|    expectedError: T) -> Bool {
      0|   40|    return actualError._domain == expectedError._domain
      0|   41|        && actualError._code   == expectedError._code
      0|   42|}
       |   43|
       |   44|internal func errorMatchesExpectedError<T: ErrorType where T: Equatable>(
       |   45|    actualError: ErrorType,
      0|   46|    expectedError: T) -> Bool {
      0|   47|    if let actualError = actualError as? T {
      0|   48|        return actualError == expectedError
      0|   49|    }
      0|   50|    return false
      0|   51|}
       |   52|
       |   53|internal func errorMatchesNonNilFieldsOrClosure<T: ErrorType>(
       |   54|    actualError: ErrorType?,
       |   55|    error: T? = nil,
       |   56|    errorType: T.Type? = nil,
      0|   57|    closure: ((T) -> Void)? = nil) -> Bool {
      0|   58|    var matches = false
      0|   59|
      0|   60|    if let actualError = actualError {
      0|   61|        matches = true
      0|   62|
      0|   63|        if let error = error {
      0|   64|            if !errorMatchesExpectedError(actualError, expectedError: error) {
      0|   65|                matches = false
      0|   66|            }
      0|   67|        }
      0|   68|        if let actualError = actualError as? T {
      0|   69|            if let closure = closure {
      0|   70|                let assertions = gatherFailingExpectations {
      0|   71|                    closure(actualError as T)
      0|   72|                }
      0|   73|                let messages = assertions.map { $0.message }
      0|   74|                if messages.count > 0 {
      0|   75|                    matches = false
      0|   76|                }
      0|   77|            }
      0|   78|        } else if errorType != nil && closure != nil {
      0|   79|            // The closure expects another ErrorType as argument, so this
      0|   80|            // is _supposed_ to fail, so that it becomes more obvious.
      0|   81|            let assertions = gatherExpectations {
      0|   82|                expect(actualError is T).to(equal(true))
      0|   83|            }
      0|   84|            precondition(assertions.map { $0.message }.count > 0)
      0|   85|            matches = false
      0|   86|        }
      0|   87|    }
      0|   88|
      0|   89|    return matches
      0|   90|}
       |   91|
       |   92|// Non-generic
       |   93|
       |   94|internal func setFailureMessageForError(
       |   95|    failureMessage: FailureMessage,
       |   96|    actualError: ErrorType?,
      0|   97|    closure: ((ErrorType) -> Void)?) {
      0|   98|    failureMessage.postfixMessage = "throw error"
      0|   99|
      0|  100|    if let _ = closure {
      0|  101|        failureMessage.postfixMessage += " that satisfies block"
      0|  102|    } else {
      0|  103|        failureMessage.postfixMessage = "throw any error"
      0|  104|    }
      0|  105|
      0|  106|    if let actualError = actualError {
      0|  107|        failureMessage.actualValue = "<\(actualError)>"
      0|  108|    } else {
      0|  109|        failureMessage.actualValue = "no error"
      0|  110|    }
      0|  111|}
       |  112|
       |  113|internal func errorMatchesNonNilFieldsOrClosure(
       |  114|    actualError: ErrorType?,
      0|  115|    closure: ((ErrorType) -> Void)?) -> Bool {
      0|  116|    var matches = false
      0|  117|
      0|  118|    if let actualError = actualError {
      0|  119|        matches = true
      0|  120|
      0|  121|        if let closure = closure {
      0|  122|            let assertions = gatherFailingExpectations {
      0|  123|                closure(actualError)
      0|  124|            }
      0|  125|            let messages = assertions.map { $0.message }
      0|  126|            if messages.count > 0 {
      0|  127|                matches = false
      0|  128|            }
      0|  129|        }
      0|  130|    }
      0|  131|
      0|  132|    return matches
      0|  133|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Utils/Functional.swift:
       |    1|import Foundation
       |    2|
       |    3|extension SequenceType {
      0|    4|    internal func all(fn: Generator.Element -> Bool) -> Bool {
      0|    5|        for item in self {
      0|    6|            if !fn(item) {
      0|    7|                return false
      0|    8|            }
      0|    9|        }
      0|   10|        return true
      0|   11|    }
       |   12|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Utils/SourceLocation.swift:
       |    1|import Foundation
       |    2|
       |    3|// Ideally we would always use `StaticString` as the type for tracking the file name
       |    4|// that expectations originate from, for consistency with `assert` etc. from the
       |    5|// stdlib, and because recent versions of the XCTest overlay require `StaticString`
       |    6|// when calling `XCTFail`. Under the Objective-C runtime (i.e. building on Mac), we
       |    7|// have to use `String` instead because StaticString can't be generated from Objective-C
       |    8|#if _runtime(_ObjC)
       |    9|public typealias FileString = String
       |   10|#else
       |   11|public typealias FileString = StaticString
       |   12|#endif
       |   13|
       |   14|public final class SourceLocation : NSObject {
       |   15|    public let file: FileString
       |   16|    public let line: UInt
       |   17|
      0|   18|    override init() {
      0|   19|        file = "Unknown File"
      0|   20|        line = 0
      0|   21|    }
       |   22|
     12|   23|    init(file: FileString, line: UInt) {
     12|   24|        self.file = file
     12|   25|        self.line = line
     12|   26|    }
       |   27|
      0|   28|    override public var description: String {
      0|   29|        return "\(file):\(line)"
      0|   30|    }
       |   31|}

/Users/wangjie/Developer/iOS/MyPods/KissPaginate/Example/Pods/Nimble/Sources/Nimble/Utils/Stringers.swift:
       |    1|import Foundation
       |    2|
       |    3|
      0|    4|internal func identityAsString(value: AnyObject?) -> String {
      0|    5|    if let value = value {
      0|    6|        return NSString(format: "<%p>", unsafeBitCast(value, Int.self)).description
      0|    7|    } else {
      0|    8|        return "nil"
      0|    9|    }
      0|   10|}
       |   11|
      0|   12|internal func classAsString(cls: AnyClass) -> String {
      0|   13|#if _runtime(_ObjC)
      0|   14|    return NSStringFromClass(cls)
      0|   15|#else
      0|   16|    return String(cls)
      0|   17|#endif
      0|   18|}
       |   19|
      0|   20|internal func arrayAsString<T>(items: [T], joiner: String = ", ") -> String {
      0|   21|    return items.reduce("") { accum, item in
      0|   22|        let prefix = (accum.isEmpty ? "" : joiner)
      0|   23|        return accum + prefix + "\(stringify(item))"
      0|   24|    }
      0|   25|}
       |   26|
       |   27|/// A type with a customized test output text representation.
       |   28|///
       |   29|/// This textual representation is produced when values will be
       |   30|/// printed in test runs, and may be useful when producing
       |   31|/// error messages in custom matchers.
       |   32|///
       |   33|/// - SeeAlso: `CustomDebugStringConvertible`
       |   34|public protocol TestOutputStringConvertible {
       |   35|    var testDescription: String { get }
       |   36|}
       |   37|
       |   38|extension Double: TestOutputStringConvertible {
      0|   39|    public var testDescription: String {
      0|   40|        return NSNumber(double: self).testDescription
      0|   41|    }
       |   42|}
       |   43|
       |   44|extension Float: TestOutputStringConvertible {
      0|   45|    public var testDescription: String {
      0|   46|        return NSNumber(float: self).testDescription
      0|   47|    }
       |   48|}
       |   49|
       |   50|extension NSNumber: TestOutputStringConvertible {
       |   51|    // This is using `NSString(format:)` instead of
       |   52|    // `String(format:)` because the latter somehow breaks
       |   53|    // the travis CI build on linux.
      0|   54|    public var testDescription: String {
      0|   55|        let description = self.description
      0|   56|        
      0|   57|        if description.containsString(".") {
      0|   58|            // Travis linux swiftpm build doesn't like casting String to NSString,
      0|   59|            // which is why this annoying nested initializer thing is here.
      0|   60|            // Maybe this will change in a future snapshot.
      0|   61|            let decimalPlaces = NSString(string: NSString(string: description)
      0|   62|                .componentsSeparatedByString(".")[1])
      0|   63|            
      0|   64|            if decimalPlaces.length > 4 {
      0|   65|                return NSString(format: "%0.4f", self.doubleValue).description
      0|   66|            }
      0|   67|        }
      0|   68|        return self.description
      0|   69|    }
       |   70|}
       |   71|
       |   72|extension Array: TestOutputStringConvertible {
      0|   73|    public var testDescription: String {
      0|   74|        let list = self.map(Nimble.stringify).joinWithSeparator(", ")
      0|   75|        return "[\(list)]"
      0|   76|    }
       |   77|}
       |   78|
       |   79|extension AnySequence: TestOutputStringConvertible {
      0|   80|    public var testDescription: String {
      0|   81|        let generator = self.generate()
      0|   82|        var strings = [String]()
      0|   83|        var value: AnySequence.Generator.Element?
      0|   84|        
      0|   85|        repeat {
      0|   86|            value = generator.next()
      0|   87|            if let value = value {
      0|   88|                strings.append(stringify(value))
      0|   89|            }
      0|   90|        } while value != nil
      0|   91|        
      0|   92|        let list = strings.joinWithSeparator(", ")
      0|   93|        return "[\(list)]"
      0|   94|    }
       |   95|}
       |   96|
       |   97|extension NSArray: TestOutputStringConvertible {
      0|   98|    public var testDescription: String {
      0|   99|        let list = Array(self).map(Nimble.stringify).joinWithSeparator(", ")
      0|  100|        return "(\(list))"
      0|  101|    }
       |  102|}
       |  103|
       |  104|extension NSIndexSet: TestOutputStringConvertible {
      0|  105|    public var testDescription: String {
      0|  106|        let list = Array(self).map(Nimble.stringify).joinWithSeparator(", ")
      0|  107|        return "(\(list))"
      0|  108|    }
       |  109|}
       |  110|
       |  111|extension String: TestOutputStringConvertible {
      0|  112|    public var testDescription: String {
      0|  113|        return self
      0|  114|    }
       |  115|}
       |  116|
       |  117|extension NSData: TestOutputStringConvertible {
      0|  118|    public var testDescription: String {
      0|  119|        #if os(Linux)
      0|  120|            // FIXME: Swift on Linux triggers a segfault when calling NSData's hash() (last checked on 03-11-16)
      0|  121|            return "NSData<length=\(self.length)>"
      0|  122|        #else
      0|  123|            return "NSData<hash=\(self.hash),length=\(self.length)>"
      0|  124|        #endif
      0|  125|    }
       |  126|}
       |  127|
       |  128|///
       |  129|/// Returns a string appropriate for displaying in test output
       |  130|/// from the provided value.
       |  131|///
       |  132|/// - parameter value: A value that will show up in a test's output.
       |  133|///
       |  134|/// - returns: The string that is returned can be
       |  135|///     customized per type by conforming a type to the `TestOutputStringConvertible`
       |  136|///     protocol. When stringifying a non-`TestOutputStringConvertible` type, this
       |  137|///     function will return the value's debug description and then its
       |  138|///     normal description if available and in that order. Otherwise it
       |  139|///     will return the result of constructing a string from the value.
       |  140|///
       |  141|/// - SeeAlso: `TestOutputStringConvertible`
       |  142|@warn_unused_result
     24|  143|public func stringify<T>(value: T) -> String {
      0|  144|    if let value = value as? TestOutputStringConvertible {
      0|  145|        return value.testDescription
     24|  146|    }
     24|  147|    
      0|  148|    if let value = value as? CustomDebugStringConvertible {
      0|  149|        return value.debugDescription
     24|  150|    }
     24|  151|    
     24|  152|    return String(value)
     24|  153|}
       |  154|
       |  155|/// -SeeAlso: `stringify<T>(value: T)`
       |  156|@warn_unused_result
     24|  157|public func stringify<T>(value: T?) -> String {
     24|  158|    if let unboxed = value {
     24|  159|        return stringify(unboxed)
      0|  160|    }
      0|  161|    return "nil"
     24|  162|}
       |  163|
       |  164|#if _runtime(_ObjC)
       |  165|@objc public class NMBStringer: NSObject {
       |  166|    @warn_unused_result
      0|  167|    @objc public class func stringify(obj: AnyObject?) -> String {
      0|  168|        return Nimble.stringify(obj)
      0|  169|    }
       |  170|}
       |  171|#endif

